<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gamification Core</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .modal.hidden, .menu-section-content.hidden, .quest-wizard-step.hidden { display: none; }
        .modal { resize: both; overflow: auto; border: 2px solid #4a5568; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); }
        #character-sidebar .sidebar-content { max-height: calc(100vh - 4rem); overflow-y: auto; }
        .achievement-icon-selector.selected { outline: 2px solid #f59e0b; background-color: #374151; }
        .gantt-quest-bar { position: absolute; height: 80%; top: 10%; border-radius: 0.25rem; cursor: grab; display: flex; align-items: center; justify-content: space-between; padding-left: 0.5rem; padding-right: 0.25rem; font-size: 0.75rem; color: white; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; border: 1px solid rgba(0,0,0,0.3); }
        .gantt-quest-bar:active { cursor: grabbing; }
        .gantt-quest-bar.project { height: 10px; top: calc(50% - 5px); background-color: #9ca3af; border-radius: 0; }
        .quest-conflict { border: 2px solid #ef4444; box-shadow: 0 0 8px #ef4444; }
        #focus-timer-visual-fill { transition: height 0.5s linear; }
        .text-shadow { text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7); }
        .wizard-progress-dot { width: 10px; height: 10px; border-radius: 50%; background-color: #4b5567; transition: background-color 0.3s; }
        .wizard-progress-dot.active { background-color: #6366f1; }
        @keyframes blink { 50% { border-color: #ef4444; } }
        #main-content.blinking-border { animation: blink 1.5s linear infinite; border-style: solid; border-width: 2px; border-color: #4b5567; }
        .gantt-conflict-segment { position: absolute; height: 100%; top: 0; background-image: repeating-linear-gradient(45deg, rgba(239, 68, 68, 0.4), rgba(239, 68, 68, 0.4) 5px, transparent 5px, transparent 10px); pointer-events: none; }
        .pet-selector.selected { border-color: #f59e0b; box-shadow: 0 0 10px #f59e0b; background-color: #374151; }
    </style>
    <style id="skills-styles">
        .skill-node {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem;
            border: 2px solid #4b5567;
            border-radius: 0.5rem;
            background-color: #374151;
            transition: all 0.2s;
            cursor: pointer;
        }
        .skill-node.selected {
            border-color: #6366f1;
            background-color: #4338ca;
        }
        .skill-node--locked {
            opacity: 0.5;
            background-color: #1f2937;
        }
        .skill-node--learnable {
            border-color: #f59e0b;
        }
        .skill-node--learnable:hover {
            background-color: #4b5567;
        }
        .skill-node--unlocked {
            border-color: #22c55e;
            background-color: #166534;
        }
        .skill-icon {
            font-size: 1.5rem;
            width: 2.5rem;
            height: 2.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.375rem;
            background-color: rgba(0,0,0,0.2);
        }
    </style>
    <style id="equipment-styles">
        .equipment-slot { background-color: #111827; border: 2px solid #4b5567; aspect-ratio: 1/1; display: flex; align-items: center; justify-content: center; transition: all 0.2s; cursor: pointer; transform: rotate(45deg); border-radius: 0.375rem; }
        .equipment-slot:hover { border-color: #9ca3af; background-color: #1f2937; }
        .equipment-slot.selected { border-color: #f59e0b; box-shadow: 0 0 10px #f59e0b; }
        .equipment-slot.blocked { background-color: #374151; cursor: not-allowed; }
        .equipment-slot > * { text-align: center; line-height: 1; transform: rotate(-45deg); }
        .slot-medium { width: 5rem; height: 5rem; }
        .slot-small { width: 4.5rem; height: 4.5rem; }
    </style>
    <style id="my-quests-styles">
        .quest-filter-btn.active { background-color: #4f46e5; font-weight: bold; }
    </style>
    <style id="inventory-styles">
        #inventory-list-container .group.selected { background-color: #3b82f6; border: 1px solid #60a5fa; }
    </style>
    <style id="pets-styles">
        #pets-inventory-list .active-pet-glow { box-shadow: 0 0 12px #f59e0b, inset 0 0 8px rgba(245, 158, 11, 0.5); }
    </style>
    <style id="journal-styles"></style>
    <style id="character-stats-styles"></style>
</head>
<body class="bg-gray-900 text-gray-200">

    <div id="global-currency-display" class="fixed top-4 right-4 z-50 flex gap-4 text-sm">
       <div class="flex items-center gap-1 p-2 bg-gray-800 rounded-lg border border-gray-600">
           <span title="Kristalle">💎</span><span id="crystals-amount">0</span>
       </div>
       <div class="flex items-center gap-1 p-2 bg-gray-800 rounded-lg border border-gray-600">
           <span title="Gold">💰</span><span id="gold-amount">0</span>
       </div>
       <div class="flex items-center gap-1 p-2 bg-gray-800 rounded-lg border border-gray-600">
           <span title="Silber">🪙</span><span id="silver-amount">0</span>
       </div>
       <div class="flex items-center gap-1 p-2 bg-gray-800 rounded-lg border border-gray-600">
           <span title="Bronze">🥉</span><span id="bronze-amount">0</span>
       </div>
    </div>

    <!-- Minimized Break Timer -->
    <div id="minimized-break-timer" class="hidden fixed top-4 left-1/2 -translate-x-1/2 z-50 bg-gray-700 text-white p-2 rounded-lg shadow-lg border border-gray-500">
        <span>Pause: </span><span id="minimized-break-timer-display" class="font-mono">05:00</span>
    </div>


    <div class="min-h-screen flex items-center justify-center p-4">
        <!-- Auth View -->
        <div id="auth-view">
            <div class="bg-gray-800 p-8 rounded-lg shadow-lg text-center max-w-md mx-auto">
                <h1 class="text-white text-3xl font-bold mb-6">Willkommen!</h1>
                <button id="login-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300">
                    Anonym Anmelden
                </button>
            </div>
        </div>

        <!-- App View -->
        <div id="app-view" class="hidden w-full max-w-screen-xl mx-auto flex gap-4">
            <!-- Left Menu -->
            <div id="main-menu-container" class="w-48 flex-shrink-0 bg-gray-800 p-4 rounded-lg shadow-lg flex flex-col gap-4">
                 <h2 class="text-xl font-bold text-center border-b border-gray-600 pb-2">Menü</h2>
                 
                 <div class="menu-section">
                    <h3 class="menu-section-header text-lg font-semibold cursor-pointer border-b border-gray-700 pb-1 mb-2">Produktion</h3>
                    <div class="menu-section-content pl-2 flex flex-col gap-2">
                        <button id="menu-btn-new-quest" class="menu-btn bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Neue Quest</button>
                        <button id="menu-btn-my-quests" class="menu-btn bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300">
                            Meine Quests
                            <div id="my-quests-counts" class="flex justify-center items-center gap-2 text-xs mt-1"></div>
                        </button>
                        <button id="menu-btn-journal" class="menu-btn bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Journal</button>
                    </div>
                 </div>

                <div class="menu-section">
                    <h3 class="menu-section-header text-lg font-semibold cursor-pointer border-b border-gray-700 pb-1 mb-2">Gamification</h3>
                    <div class="menu-section-content pl-2 flex flex-col gap-2">
                        <button id="menu-btn-pets" class="menu-btn bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Pets</button>
                    </div>
                </div>


                 <div class="mt-auto border-t border-gray-600 pt-4 space-y-2">
                     <h3 class="text-xs text-gray-400 text-center">Test-Tools</h3>
                     <div id="test-buttons-container" class="flex flex-col gap-2">
                         <button id="test-levelup-btn" class="text-xs bg-yellow-600 hover:bg-yellow-500 p-1 rounded">Level Up</button>
                         <button id="test-add-bronze-btn" class="text-xs bg-yellow-700 hover:bg-yellow-600 p-1 rounded">+125 Bronze</button>
                         <button id="test-timer-usage-btn" class="text-xs bg-teal-600 hover:bg-teal-500 p-1 rounded">+1 Timer Usage</button>
                         <button id="test-add-today-quests-btn" class="text-xs bg-blue-600 hover:bg-blue-500 p-1 rounded">+5 Quests für Heute</button>
                         <button id="test-complete-all-quests-btn" class="text-xs bg-red-600 hover:bg-red-500 p-1 rounded">Alle Quests erledigen</button>
                         <button id="test-gain-pet-xp-btn" class="text-xs bg-purple-600 hover:bg-purple-500 p-1 rounded">+50 Pet XP</button>
                         <button data-count="5" data-priority="Leicht" class="add-test-quests-btn text-xs bg-gray-600 hover:bg-gray-500 p-1 rounded">+5 Leicht</button>
                         <button data-count="5" data-priority="Mittel" class="add-test-quests-btn text-xs bg-gray-600 hover:bg-gray-500 p-1 rounded">+5 Mittel</button>
                         <button data-count="5" data-priority="Schwer" class="add-test-quests-btn text-xs bg-gray-600 hover:bg-gray-500 p-1 rounded">+5 Schwer</button>
                     </div>
                 </div>

                 <div class="mt-4">
                    <button id="logout-btn" class="w-full bg-red-800 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Abmelden & Löschen</button>
                 </div>
            </div>

            <!-- Main Content -->
            <div id="main-content-container" class="flex-grow flex flex-col gap-4">
                <div class="bg-gray-800 p-4 rounded-lg shadow-lg text-white flex flex-col h-[350px]">
                    <div class="flex justify-between items-center mb-2 flex-shrink-0">
                        <h3 class="font-bold text-lg">Projekt-Übersicht</h3>
                        <div id="gantt-controls" class="flex items-center gap-4 text-sm">
                            <label>Projekt: 
                                <select id="gantt-project-filter" class="bg-gray-900 rounded p-1">
                                    <option value="">Alle</option>
                                </select>
                            </label>
                            <label>Startzeit: <input type="time" id="gantt-start-time" value="16:00" step="900" class="bg-gray-900 rounded p-1"></label>
                            <label>Datum: <input type="date" id="gantt-date" class="bg-gray-900 rounded p-1"></label>
                            <label class="flex items-center gap-2 cursor-pointer">
                                <input type="checkbox" id="gantt-auto-pause-toggle">
                                <span>Auto. Pause</span>
                            </label>
                            <div class="border-l border-gray-600 pl-4">
                                <select id="gantt-view-select" class="bg-gray-700 text-white border-gray-600 rounded p-1 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500">
                                    <option value="day">Tagesansicht</option>
                                    <option value="week">Wochenansicht</option>
                                    <option value="single-line">Eine Zeile</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="flex-grow overflow-auto">
                        <div id="gantt-chart-container" class="grid grid-cols-[250px_1fr] text-sm gap-y-1 relative">
                        </div>
                    </div>
                </div>
                
                <div id="main-content" class="bg-gray-800 p-6 rounded-lg shadow-lg text-white flex-grow">
                     <div id="focus-quest-container">
                     </div>
                </div>
            </div>
            
            <!-- Right Character Sidebar -->
            <div id="character-sidebar" class="w-96 flex-shrink-0 bg-gray-800 p-4 rounded-lg shadow-lg flex flex-col">
                <div class="sidebar-content overflow-y-auto">
                    <div class="text-center mb-4">
                        <div class="flex justify-center items-center gap-2">
                           <h2 id="character-name" class="text-xl font-bold"></h2>
                           <span class="text-sm font-bold text-green-400">(Level <span id="character-level">1</span>)</span>
                        </div>
                        <div id="character-achievements-display" class="flex justify-center flex-wrap gap-1 mt-1 h-6"></div>
                        <img id="character-image" src="https://placehold.co/128x128/374151/e5e7eb.png?text=Charakter" alt="Character Portrait" class="mx-auto my-2 rounded-lg border-2 border-gray-600">
                        <div id="active-pets-sidebar" class="flex justify-center items-center gap-2 mt-2 h-8"></div>
                    </div>
                
                    <div id="ui-block-player-info">
                         <div class="mt-2 space-y-3">
                            <div class="flex items-center">
                                <div class="flex-grow">
                                    <span class="text-sm font-bold text-red-400">HP</span>
                                    <div class="w-full bg-gray-600 rounded-full h-4 relative border border-gray-500">
                                        <div id="hp-bar-fill" class="bg-red-500 h-full rounded-full" style="width: 100%;"></div>
                                        <span id="hp-bar-text" class="absolute inset-0 text-white text-xs font-bold flex items-center justify-center">100 / 100</span>
                                    </div>
                                </div>
                                <button id="use-hp-potion-btn" class="group flex items-center gap-1 ml-3 flex-shrink-0" title="Heiltrank benutzen">
                                    <span class="text-lg transition-transform group-hover:scale-125">🧪</span>
                                    <span id="hp-potion-count" class="text-sm font-bold min-w-[1rem] text-center">0</span>
                                </button>
                            </div>
                             <div class="flex items-center">
                                <div class="flex-grow">
                                    <span class="text-sm font-bold text-blue-400">Mana</span>
                                    <div class="w-full bg-gray-600 rounded-full h-4 relative border border-gray-500">
                                        <div id="mana-bar-fill" class="bg-blue-500 h-full rounded-full" style="width: 100%;"></div>
                                        <span id="mana-bar-text" class="absolute inset-0 text-white text-xs font-bold flex items-center justify-center">100 / 100</span>
                                    </div>
                                </div>
                                <button id="use-mana-potion-btn" class="group flex items-center gap-1 ml-3 flex-shrink-0" title="Manatrank benutzen">
                                    <span class="text-lg transition-transform group-hover:scale-125">💧</span>
                                    <span id="mana-potion-count" class="text-sm font-bold min-w-[1rem] text-center">0</span>
                                </button>
                            </div>
                             <div>
                                 <span class="text-sm font-bold text-green-400">Ausdauer</span>
                                 <div class="w-full bg-gray-600 rounded-full h-4 relative border border-gray-500">
                                     <div id="stamina-bar-fill" class="bg-green-500 h-full rounded-full" style="width: 100%;"></div>
                                     <span id="stamina-bar-text" class="absolute inset-0 text-white text-xs font-bold flex items-center justify-center">100 / 100</span>
                                 </div>
                             </div>
                        </div>
                        <div id="xp-section" class="mt-4">
                            <div id="xp-bar-container" class="w-full bg-gray-600 rounded-full h-2.5">
                                <div id="xp-bar-progress" class="bg-yellow-400 h-2.5 rounded-full" style="width: 0%"></div>
                            </div>
                            <p class="text-sm text-right text-gray-300 mt-1">
                                <span id="xp-current-in-level">0</span> / <span id="xp-needed-for-level">100</span> XP
                            </p>
                        </div>
                    </div>
                     <hr class="my-4 border-gray-600">

                     <div class="grid grid-cols-2 gap-2 my-4">
                         <button id="menu-btn-equipment" class="menu-btn bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-2 rounded-lg transition duration-300 text-sm">Ausrüstung</button>
                         <button id="menu-btn-inventory" class="menu-btn bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-2 rounded-lg transition duration-300 text-sm">Inventar</button>
                         <button id="menu-btn-achievements" class="menu-btn bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-2 rounded-lg transition duration-300 text-sm">Erfolge</button>
                         <button id="open-skills-btn" class="menu-btn bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-2 rounded-lg transition duration-300 text-sm">Skills</button>
                     </div>
                     
                     <div class="flex gap-4">
                        <div id="ui-block-character-stats" class="space-y-3 text-left flex-1">
                             <h3 class="text-lg font-bold text-center mb-2">Attribute</h3>
                            <div class="flex justify-between items-center text-sm"><span><span>❤️</span> Vitalität: <span id="stat-vitality">10</span></span><div class="flex items-center relative gap-1"><button data-stat="vitality" data-amount="1" class="stat-increase-btn hidden bg-green-500 hover:bg-green-600 px-2 rounded text-xs">+</button><button data-stat="vitality" data-amount="5" class="stat-increase-btn hidden bg-blue-500 hover:bg-blue-600 px-2 rounded text-xs">+5</button></div></div>
                            <div class="flex justify-between items-center text-sm"><span><span>💪</span> Stärke: <span id="stat-strength">10</span></span><div class="flex items-center relative gap-1"><button data-stat="strength" data-amount="1" class="stat-increase-btn hidden bg-green-500 hover:bg-green-600 px-2 rounded text-xs">+</button><button data-stat="strength" data-amount="5" class="stat-increase-btn hidden bg-blue-500 hover:bg-blue-600 px-2 rounded text-xs">+5</button></div></div>
                            <div class="flex justify-between items-center text-sm"><span><span>🤸</span> Agilität: <span id="stat-agility">10</span></span><div class="flex items-center relative gap-1"><button data-stat="agility" data-amount="1" class="stat-increase-btn hidden bg-green-500 hover:bg-green-600 px-2 rounded text-xs">+</button><button data-stat="agility" data-amount="5" class="stat-increase-btn hidden bg-blue-500 hover:bg-blue-600 px-2 rounded text-xs">+5</button></div></div>
                            <div class="flex justify-between items-center text-sm"><span><span>🧠</span> Intelligenz: <span id="stat-int">10</span></span><div class="flex items-center relative gap-1"><button data-stat="int" data-amount="1" class="stat-increase-btn hidden bg-green-500 hover:bg-green-600 px-2 rounded text-xs">+</button><button data-stat="int" data-amount="5" class="stat-increase-btn hidden bg-blue-500 hover:bg-blue-600 px-2 rounded text-xs">+5</button></div></div>
                            <div class="flex justify-between items-center text-sm"><span><span>🏃</span> Ausdauer: <span id="stat-stamina">10</span></span><div class="flex items-center relative gap-1"><button data-stat="stamina" data-amount="1" class="stat-increase-btn hidden bg-green-500 hover:bg-green-600 px-2 rounded text-xs">+</button><button data-stat="stamina" data-amount="5" class="stat-increase-btn hidden bg-blue-500 hover:bg-blue-600 px-2 rounded text-xs">+5</button></div></div>
                            <div class="flex justify-between items-center text-sm"><span><span>🍀</span> Glück: <span id="stat-luck">10</span></span><div class="flex items-center relative gap-1"><button data-stat="luck" data-amount="1" class="stat-increase-btn hidden bg-green-500 hover:bg-green-600 px-2 rounded text-xs">+</button><button data-stat="luck" data-amount="5" class="stat-increase-btn hidden bg-blue-500 hover:bg-blue-600 px-2 rounded text-xs">+5</button></div></div>
                        </div>
                        <div id="sidebar-derived-stats" class="space-y-2 text-left text-sm flex-1">
                            <h3 class="text-lg font-bold text-center mb-2">Kampfwerte</h3>
                            <p>Physischer Dmg: <span id="derived-stat-phys-dmg" class="font-bold text-green-400">0</span></p>
                            <p>Verteidigung: <span id="derived-stat-def" class="font-bold text-green-400">0</span></p>
                            <p>Ausweichen: <span id="derived-stat-dodge" class="font-bold text-green-400">0%</span></p>
                            <p>Elementar Dmg: <span id="derived-stat-ele-dmg" class="font-bold text-green-400">0</span></p>
                        </div>
                     </div>

                     <p id="stat-points-container" class="text-center mt-4 hidden pt-2 border-t border-gray-600">Punkte zu vergeben: <span id="stat-points-display-footer">0</span></p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Notification Area -->
    <div id="notification-area" class="fixed top-5 right-5 bg-blue-500 text-white p-3 rounded-lg shadow-lg opacity-0 transition-opacity duration-500 z-50"></div>

    <!-- #################### -->
    <!-- ## FLOATING MODALS ## -->
    <!-- #################### -->

    <!-- My Quests Modal -->
    <div id="my-quests-modal" class="modal hidden fixed top-1/4 left-1/3 w-[800px] h-[70vh] z-40">
        <div class="bg-gray-800 text-white rounded-lg h-full flex flex-col">
             <div class="p-2 bg-gray-700 flex justify-between items-center cursor-move modal-header">
                <h3 class="font-bold">Meine Quests</h3>
                <button class="modal-close-btn text-xl font-bold hover:text-red-500">&times;</button>
            </div>
            <div id="quest-list-filters" class="p-2 flex items-center gap-4 border-b border-gray-700 text-sm">
                <label>Sortieren nach:
                    <select id="quest-sort-select" class="bg-gray-900 rounded p-1">
                        <option value="priority">Priorität</option>
                        <option value="createdAt">Erstellt am</option>
                        <option value="text">Titel</option>
                        <option value="xp">XP</option>
                    </select>
                </label>
                <div class="border-l border-gray-600 pl-4 flex gap-2">
                    <button data-filter="all" class="quest-filter-btn px-2 py-1 bg-indigo-600 rounded text-sm active">Alle</button>
                    <button data-filter="dueToday" class="quest-filter-btn px-2 py-1 bg-gray-600 rounded text-sm">Heute fällig</button>
                    <button data-filter="dueThisWeek" class="quest-filter-btn px-2 py-1 bg-gray-600 rounded text-sm">Woche fällig</button>
                </div>
            </div>
            <div id="todo-list" class="p-4 space-y-2 overflow-y-auto flex-grow"></div>
        </div>
    </div>

    <!-- New Quest Modal -->
    <div id="new-quest-modal" class="modal hidden fixed top-1/4 left-1/3 w-[600px] z-40">
        <div class="bg-gray-800 text-white rounded-lg h-full flex flex-col">
            <div class="p-2 bg-gray-700 flex justify-between items-center cursor-move modal-header">
                <h3 class="font-bold">Neue Quest erstellen</h3>
                <button class="modal-close-btn text-xl font-bold hover:text-red-500">&times;</button>
            </div>
            <div class="p-4 overflow-y-auto">
                 <form id="add-todo-form" class="space-y-4 text-sm">
                    <!-- Step 1: Type -->
                     <div id="quest-step-1" class="quest-wizard-step space-y-4">
                        <h4 class="text-lg font-semibold text-center text-gray-400">Schritt 1: Typ</h4>
                        <div>
                            <label class="block text-xs font-medium text-gray-400 mb-1">Typ</label>
                            <select id="todo-task-type" class="w-full bg-gray-700 text-white rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                                <option value="Aufgabe">Aufgabe</option>
                                <option value="Projektaufgabe">Projektaufgabe</option>
                                <option value="Projekt">Projekt</option>
                            </select>
                        </div>
                        <div id="todo-parent-project-container" class="hidden">
                             <label class="block text-xs font-medium text-gray-400 mb-1">Übergeordnetes Projekt</label>
                             <select id="todo-parent-project" class="w-full bg-gray-700 text-white rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                                 <option value="">Kein Projekt ausgewählt</option>
                             </select>
                         </div>
                    </div>
                    <!-- Step 2: Basic Info -->
                    <div id="quest-step-2" class="quest-wizard-step hidden space-y-4">
                        <h4 class="text-lg font-semibold text-center text-gray-400">Schritt 2: Titel & Beschreibung</h4>
                        <input type="text" id="todo-input" class="w-full bg-gray-700 text-white rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="Quest-Titel..." required>
                        <div>
                            <button type="button" id="toggle-details-btn" class="text-sm text-indigo-400 hover:text-indigo-300">Beschreibung hinzufügen +</button>
                            <div id="details-toggle-content" class="hidden mt-2">
                                <textarea id="todo-details" class="w-full bg-gray-700 text-white rounded-lg px-4 py-2 h-24 focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="Zusätzliche Notizen, Ziele oder Template-Text..."></textarea>
                            </div>
                        </div>
                    </div>
                    <!-- Step 3: Duration -->
                     <div id="quest-step-3" class="quest-wizard-step hidden space-y-4">
                        <h4 class="text-lg font-semibold text-center text-gray-400">Schritt 3: Dauer (Pflichtfeld)</h4>
                        <div id="duration-container-task">
                            <div class="flex justify-between items-center mb-2">
                                <label class="block text-xs font-medium text-gray-400">Dauer</label>
                                <button type="button" id="duration-mode-toggle" class="text-xs text-indigo-400 hover:text-indigo-300">Manuelle Eingabe</button>
                            </div>
                            <div id="Bearbeitungsdauer-Pomodoro">
                                <div class="flex items-center gap-4 p-2 bg-gray-900 rounded-lg">
                                    <span id="quest-duration-display" class="font-mono text-2xl font-bold text-white">0m</span>
                                    <div class="flex-grow flex justify-end gap-2">
                                        <button type="button" data-add-duration="25" class="duration-add-btn bg-blue-600 hover:bg-blue-500 rounded px-3 py-1">+25m</button>
                                        <button type="button" data-add-duration="45" class="duration-add-btn bg-blue-600 hover:bg-blue-500 rounded px-3 py-1">+45m</button>
                                        <button type="button" id="duration-reset-btn" class="bg-red-600 hover:bg-red-500 rounded px-3 py-1">Reset</button>
                                    </div>
                                </div>
                            </div>
                            <div id="Bearbeitungsdauer-Frei" class="hidden">
                                <input type="text" id="quest-duration-free-input" class="w-full bg-gray-700 text-white rounded-lg px-4 py-2" placeholder="z.B. 1h 30m, 90m, 2h...">
                            </div>
                        </div>
                        <div id="duration-container-project" class="hidden">
                            <label class="block text-xs font-medium text-gray-400 mb-1">Dauer (Tage)</label>
                            <input type="number" id="project-duration-days" min="1" value="7" class="w-full bg-gray-700 text-white rounded-lg px-4 py-2">
                        </div>
                    </div>
                     <!-- Step 4: Deadline & Repeat -->
                      <div id="quest-step-4" class="quest-wizard-step hidden space-y-4">
                        <h4 class="text-lg font-semibold text-center text-gray-400">Schritt 4: Deadline & Wiederholung</h4>
                         <div id="deadline-container">
                            <label class="block text-xs font-medium text-gray-400 mb-1">Deadline (Pflichtfeld)</label>
                            <input type="date" id="todo-deadline" class="w-full bg-gray-700 text-white rounded-lg px-4 py-2">
                        </div>
                        <div id="start-date-container" class="hidden">
                            <label class="block text-xs font-medium text-gray-400 mb-1">Start-Datum (Pflichtfeld)</label>
                            <input type="date" id="project-start-date" class="w-full bg-gray-700 text-white rounded-lg px-4 py-2">
                        </div>
                        <div class="pt-2" id="repeat-section">
                            <label class="flex items-center gap-2">
                                <input type="checkbox" id="todo-repeat" class="form-checkbox bg-gray-700 border-gray-600 text-indigo-500 focus:ring-indigo-500">
                                <span>Tägliche Quest? (Wiederholbar)</span>
                            </label>
                            <div id="todo-repeat-options-container" class="hidden mt-2 space-y-2">
                                <p class="text-xs text-yellow-400 p-2 bg-yellow-900 bg-opacity-40 rounded-lg">Tägliche Quests sind immer 'Leicht', geben +30 Bronze und kosten 5 HP, wenn sie verpasst werden.</p>
                                <div>
                                    <label class="block text-xs font-medium text-gray-400 mb-1">Startzeit (Pflichtfeld)</label>
                                    <input type="time" id="todo-start-time" class="w-full bg-gray-700 text-white rounded-lg px-4 py-2">
                                </div>
                                <div id="todo-repeat-days-container" class="flex flex-wrap gap-x-3 gap-y-1 text-sm text-gray-300"></div>
                            </div>
                        </div>
                    </div>
                    <!-- Step 5: Details -->
                     <div id="quest-step-5" class="quest-wizard-step hidden space-y-4">
                         <h4 class="text-lg font-semibold text-center text-gray-400">Schritt 5: Details</h4>
                         <div id="priority-container">
                            <label class="block text-xs font-medium text-gray-400 mb-1">Priorität</label>
                            <select id="todo-priority" class="w-full bg-gray-700 text-white rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                                <option value="Leicht">Leicht</option>
                                <option value="Mittel" selected>Mittel</option>
                                <option value="Schwer">Schwer</option>
                            </select>
                        </div>
                        <div>
                             <label class="block text-sm font-medium text-gray-400 mb-2">Tag (1 auswählen)</label>
                            <div id="todo-tags-container" class="flex flex-wrap gap-x-4 gap-y-2 p-2 rounded-lg border border-transparent"></div>
                        </div>
                    </div>
                </form>
                <div id="quest-wizard-progress" class="flex justify-center gap-2 mt-4"></div>
                <div id="quest-wizard-nav" class="mt-6 flex justify-between">
                    <button id="quest-back-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Zurück</button>
                    <button id="quest-next-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 disabled:bg-gray-500 disabled:cursor-not-allowed" disabled>Weiter</button>
                    <button id="quest-submit-btn" type="submit" form="add-todo-form" class="hidden bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Quest Hinzufügen</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Journal Modal -->
    <div id="journal-modal" class="modal hidden fixed top-1/4 left-1/2 w-[500px] z-40">
        <div class="bg-gray-800 text-white rounded-lg h-full flex flex-col">
             <div class="p-2 bg-gray-700 flex justify-between items-center cursor-move modal-header">
                <h3 class="font-bold">Journal</h3>
                <button class="modal-close-btn text-xl font-bold hover:text-red-500">&times;</button>
            </div>
            <div id="journal-list" class="p-4 space-y-2 overflow-y-auto"></div>
        </div>
    </div>
    
    <!-- Achievements Modal -->
    <div id="achievements-modal" class="modal hidden fixed top-1/4 left-1/2 w-[700px] z-40">
        <div class="bg-gray-800 text-white rounded-lg h-full flex flex-col">
            <div class="p-2 bg-gray-700 flex justify-between items-center cursor-move modal-header">
                <h3 class="font-bold">Erfolge</h3>
                <button class="modal-close-btn text-xl font-bold hover:text-red-500">&times;</button>
            </div>
            <div class="flex p-4 flex-grow gap-4 overflow-hidden">
                <div id="achievements-list" class="w-5/6 space-y-3 overflow-y-auto pr-2"></div>
                <div class="w-1/6 border-l border-gray-600 pl-4">
                    <h4 class="text-sm font-bold text-gray-400 mb-2 text-center">Angezeigte Symbole</h4>
                    <div id="achievement-icons-selection" class="flex flex-wrap gap-2 justify-center"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Equipment Modal -->
    <div id="equipment-modal" class="modal hidden fixed top-1/4 left-1/3 w-[1035px] h-[750px] z-40">
        <div class="bg-gray-800 text-white rounded-lg h-full flex flex-col">
            <div class="p-2 bg-gray-700 flex justify-between items-center">
                <h3 class="font-bold cursor-move modal-header flex-grow">Ausrüstung</h3>
                <button id="unequip-all-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-2 rounded-lg text-xs mr-2">Alles ablegen</button>
                <button class="modal-close-btn text-xl font-bold hover:text-red-500">&times;</button>
            </div>
             <div id="equipment-slots-container" class="flex p-4 flex-grow gap-4 overflow-auto">
                 <!-- Column 1: Weapons, Tools & Stats -->
                <div class="w-1/3 flex-shrink-0 flex flex-col gap-4">
                    <div>
                        <h4 class="text-lg font-bold text-gray-400 text-center mb-4">Waffen & Werkzeuge</h4>
                        <div class="grid grid-cols-2 grid-rows-2 gap-4 w-full justify-items-center items-center pt-4">
                            <div data-slot-type="weapon1" class="equipment-slot w-32 h-32 text-gray-400">Waffe 1</div>
                            <div data-slot-type="weapon2" class="equipment-slot w-32 h-32 text-gray-400">Waffe 2</div>
                            <div data-slot-type="tool1" class="equipment-slot slot-medium text-gray-400">Werkzeug 1</div>
                            <div data-slot-type="tool2" class="equipment-slot slot-medium text-gray-400">Werkzeug 2</div>
                        </div>
                    </div>
                    <div id="equipment-item-details" class="bg-gray-900 p-4 rounded-lg border border-gray-600 mt-4 flex-grow"></div>
                </div>
                <!-- Column 2: Armor -->
                <div class="w-2/3 flex-shrink-0 flex flex-col gap-4">
                     <h4 class="text-lg font-bold text-gray-400 text-center mb-4">Rüstung & Schmuck</h4>
                     <div class="grid grid-cols-3 gap-y-2 gap-x-2 justify-items-center items-center w-full h-full">
                        <div></div>
                        <div data-slot-type="head" class="equipment-slot w-24 h-24 text-gray-400">Kopf</div>
                        <div></div>
                        <div></div>
                        <div data-slot-type="amulet" class="equipment-slot slot-small text-gray-400">Amulett</div>
                        <div></div>
                        <div data-slot-type="hands" class="equipment-slot w-24 h-24 text-gray-400 -mt-4">Hände</div>
                        <div data-slot-type="chest" class="equipment-slot w-24 h-24 text-gray-400 -mt-4">Brust</div>
                        <div data-slot-type="bracers" class="equipment-slot w-24 h-24 text-gray-400 -mt-4">Armschienen</div>
                        <div data-slot-type="ring1" class="equipment-slot slot-small text-gray-400">Ring 1</div>
                        <div data-slot-type="legs" class="equipment-slot w-24 h-24 text-gray-400">Beine</div>
                        <div data-slot-type="ring2" class="equipment-slot slot-small text-gray-400">Ring 2</div>
                        <div></div>
                        <div data-slot-type="feet" class="equipment-slot w-24 h-24 text-gray-400">Füße</div>
                        <div></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Pomodoro Timer Modal -->
    <div id="pomodoro-modal" class="modal hidden fixed top-1/4 left-1/3 w-[400px] z-40">
        <div class="bg-gray-800 text-white rounded-lg h-full flex flex-col">
            <div class="p-2 bg-gray-700 flex justify-between items-center cursor-move modal-header">
                <h3 class="font-bold">Pomodoro Timer</h3>
                <button class="modal-close-btn text-xl font-bold hover:text-red-500">&times;</button>
            </div>
            <div class="p-4 flex flex-col items-center">
                <div id="timer-display" class="text-6xl font-mono text-center my-4">25:00</div>
                <p id="timer-mode-display" class="mb-4 text-gray-400">Modus: Arbeit</p>
                <div class="mb-4">
                    <h4 class="text-sm font-bold mb-2 text-center text-gray-300">Arbeit</h4>
                    <div class="flex gap-2">
                        <button class="timer-select-btn px-3 py-1 bg-blue-600 hover:bg-blue-500 rounded text-sm" data-minutes="25" data-mode="Arbeit">25 Min</button>
                        <button class="timer-select-btn px-3 py-1 bg-blue-600 hover:bg-blue-500 rounded text-sm" data-minutes="45" data-mode="Arbeit">45 Min</button>
                    </div>
                </div>
                 <div class="mb-6">
                    <h4 class="text-sm font-bold mb-2 text-center text-gray-300">Pause</h4>
                    <div class="flex gap-2">
                        <button class="timer-select-btn px-3 py-1 bg-green-600 hover:bg-green-500 rounded text-sm" data-minutes="5" data-mode="Pause">5 Min</button>
                        <button class="timer-select-btn px-3 py-1 bg-green-600 hover:bg-green-500 rounded text-sm" data-minutes="10" data-mode="Pause">10 Min</button>
                         <button class="timer-select-btn px-3 py-1 bg-green-600 hover:bg-green-500 rounded text-sm" data-minutes="30" data-mode="Pause">30 Min</button>
                    </div>
                </div>
                <div class="flex gap-4">
                    <button id="timer-start-btn" class="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded font-bold">Start</button>
                    <button id="timer-pause-btn" class="px-4 py-2 bg-yellow-600 hover:bg-yellow-500 rounded font-bold">Pause</button>
                    <button id="timer-reset-btn" class="px-4 py-2 bg-red-600 hover:bg-red-500 rounded font-bold">Reset</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Inventory Modal -->
    <div id="inventory-modal" class="modal hidden fixed top-1/4 left-1/2 w-[700px] h-[500px] z-40">
        <div class="bg-gray-800 text-white rounded-lg h-full flex flex-col">
            <div class="p-2 bg-gray-700 flex justify-between items-center cursor-move modal-header">
                 <h3 class="font-bold">Inventar</h3>
                <button class="modal-close-btn text-xl font-bold hover:text-red-500">&times;</button>
            </div>
             <div class="p-2 border-b border-gray-700 flex gap-2 text-xs flex-wrap" id="inventory-sort-buttons">
                <button data-sort-category="all" class="px-2 py-1 bg-indigo-600 rounded">Alle</button>
                <button data-sort-category="weapon" class="px-2 py-1 bg-gray-600 rounded">Waffen</button>
                <button data-sort-category="armor" class="px-2 py-1 bg-gray-600 rounded">Rüstung</button>
                <button data-sort-category="accessory" class="px-2 py-1 bg-gray-600 rounded">Accessoires</button>
                <button data-sort-category="tool" class="px-2 py-1 bg-gray-600 rounded">Werkzeuge</button>
                <button data-sort-category="consumable" class="px-2 py-1 bg-gray-600 rounded">Tränke</button>
                <button data-sort-category="spell" class="px-2 py-1 bg-gray-600 rounded">Zauber</button>
                <button data-sort-category="card" class="px-2 py-1 bg-gray-600 rounded">Karten</button>
                <button data-sort-category="pet" class="px-2 py-1 bg-gray-600 rounded">Pets</button>
            </div>
            <div class="flex p-4 flex-grow gap-4 overflow-hidden">
                <div id="inventory-list-container" class="space-y-3 overflow-y-auto flex-grow pr-2"></div>
                 <div id="inventory-item-details" class="w-2/5 flex-shrink-0 bg-gray-900 p-4 rounded-lg border border-gray-600 flex flex-col">
                 </div>
            </div>
            <div id="inventory-pagination" class="p-2 flex justify-center items-center gap-4 border-t border-gray-700">
                <button id="inventory-page-prev" class="px-3 py-1 bg-indigo-600 rounded disabled:bg-gray-500">&lt;</button>
                <span id="inventory-page-info">Seite 1 / 1</span>
                <button id="inventory-page-next" class="px-3 py-1 bg-indigo-600 rounded disabled:bg-gray-500">&gt;</button>
            </div>
        </div>
    </div>

    <!-- Pets Modal -->
    <div id="pets-modal" class="modal hidden fixed top-1/4 left-1/3 w-[800px] z-40">
        <div class="bg-gray-800 text-white rounded-lg h-full flex flex-col">
            <div class="p-2 bg-gray-700 flex justify-between items-center cursor-move modal-header">
                <h3 class="font-bold">Meine Pets</h3>
                <button class="modal-close-btn text-xl font-bold hover:text-red-500">&times;</button>
            </div>
            <div class="flex p-4 flex-grow gap-4 overflow-hidden">
                <!-- Left Column: Pet Inventory -->
                <div class="w-2/5 flex flex-col gap-3">
                    <div id="pets-inventory-filters" class="flex-shrink-0 flex gap-2 text-sm">
                        <select id="pet-filter-element" class="flex-grow bg-gray-700 p-1 rounded">
                            <option value="all">Alle Elemente</option>
                            <option value="Erde">Erde</option>
                            <option value="Wasser">Wasser</option>
                            <option value="Schatten">Schatten</option>
                            <option value="Feuer">Feuer</option>
                            <option value="Elektro">Elektro</option>
                            <option value="Eis">Eis</option>
                            <option value="Dunkel">Dunkel</option>
                        </select>
                        <select id="pet-filter-rarity" class="flex-grow bg-gray-700 p-1 rounded">
                            <option value="all">Alle Seltenheiten</option>
                            <option value="common">Gewöhnlich</option>
                            <option value="magic">Magisch</option>
                            <option value="rare">Selten</option>
                            <option value="epic">Episch</option>
                        </select>
                    </div>
                    <div id="pets-inventory-list" class="flex-grow space-y-2 overflow-y-auto pr-2">
                        <!-- Pet items will be rendered here -->
                    </div>
                    <div id="pets-inventory-pagination" class="flex-shrink-0 p-2 flex justify-center items-center gap-4 border-t border-gray-700">
                        <button id="pets-page-prev" class="px-3 py-1 bg-indigo-600 rounded disabled:bg-gray-500">&lt;</button>
                        <span id="pets-page-info">Seite 1 / 1</span>
                        <button id="pets-page-next" class="px-3 py-1 bg-indigo-600 rounded disabled:bg-gray-500">&gt;</button>
                    </div>
                </div>
                <!-- Right Column: Details/Comparison -->
                <div id="pets-details-view" class="w-3/5 bg-gray-900 p-4 rounded-lg border border-gray-600 flex flex-col">
                    <!-- Details will be rendered here -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- Skill Tree Modal -->
    <div id="skill-tree-modal" class="modal hidden fixed top-1/4 left-1/3 w-[800px] h-[70vh] z-40">
        <div class="bg-gray-800 text-white rounded-lg h-full flex flex-col">
             <div class="p-2 bg-gray-700 flex justify-between items-center cursor-move modal-header">
                <h3 class="font-bold">Charakter-Skills</h3>
                <button class="modal-close-btn text-xl font-bold hover:text-red-500">&times;</button>
            </div>
            <div class="p-4 border-b border-gray-700 text-center">
                Verfügbare Skill-Punkte: <span id="skill-points-display" class="font-bold text-yellow-400 text-lg">0</span>
            </div>
            <div id="skill-tree-container" class="p-4 flex gap-4 overflow-hidden flex-grow">
                <div id="skill-list-panel" class="w-1/3 space-y-2 overflow-y-auto pr-2 border-r border-gray-600">
                    <!-- Skill icons will be rendered here -->
                </div>
                <div id="skill-detail-panel" class="w-2/3 flex flex-col">
                    <!-- Skill details will be rendered here -->
                </div>
            </div>
            <div class="p-2 border-t border-gray-700 text-right">
                <button id="reset-skills-btn" class="text-xs bg-red-800 hover:bg-red-700 text-white font-bold py-1 px-3 rounded-lg">Skills zurücksetzen (Test)</button>
            </div>
        </div>
    </div>


    <!-- Item Found Modal -->
    <div id="item-found-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-gray-700 p-6 rounded-lg text-center shadow-xl text-white">
            <h3 class="text-xl mb-4">Gegenstand gefunden!</h3>
            <div id="modal-item-icon" class="text-5xl mb-2"></div>
            <p id="modal-item-name" class="font-bold mb-4"></p>
            <div class="flex justify-center gap-4">
                <button id="modal-keep-btn" class="bg-green-500 hover:bg-green-600 px-4 py-2 rounded">Behalten</button>
                <button id="modal-discard-btn" class="bg-red-600 hover:bg-red-700 px-4 py-2 rounded">Verwerfen</button>
            </div>
        </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <div id="delete-confirm-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-gray-700 p-6 rounded-lg text-center shadow-xl text-white">
            <h3 class="text-xl mb-4">Wirklich löschen?</h3>
            <p id="delete-confirm-text" class="text-gray-300 mb-4">Diese Aktion kann nicht rückgängig gemacht werden.</p>
            <div class="flex justify-center gap-4">
                <button id="delete-confirm-btn" class="bg-red-600 hover:bg-red-700 px-4 py-2 rounded">Ja, löschen</button>
                <button id="delete-cancel-btn" class="bg-gray-500 hover:bg-gray-600 px-4 py-2 rounded">Abbrechen</button>
            </div>
        </div>
    </div>
    
    <!-- Break Popup Modal -->
    <div id="break-popup-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[60]">
        <div class="bg-gray-800 p-8 rounded-lg text-center shadow-xl text-white w-96">
            <h3 class="text-2xl font-bold mb-4">Zeit für eine Pause!</h3>
            <div id="break-timer-display" class="text-7xl font-mono my-6">05:00</div>
            <div class="flex justify-center gap-4 mb-6">
                <button id="extend-break-5-btn" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded">+5 Min</button>
                <button id="extend-break-25-btn" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded">+25 Min</button>
            </div>
            <button id="close-break-popup-btn" class="text-sm text-gray-400 hover:text-white">Popup schließen (Timer läuft weiter)</button>
        </div>
    </div>

    <!-- Post-Break Continue Modal -->
    <div id="post-break-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[60]">
        <div class="bg-gray-800 p-8 rounded-lg text-center shadow-xl text-white">
            <h3 class="text-2xl font-bold mb-4">Pause vorbei!</h3>
            <p class="mb-6">Bereit, weiterzumachen?</p>
            <button id="continue-quest-btn" class="bg-green-600 hover:bg-green-700 px-6 py-3 rounded font-bold">Weiter</button>
        </div>
    </div>
    
    <!-- Main Application Logic -->
    <script type="application/json" id="skills-data">[
      {
        "id": "skill_toughness_1",
        "name": "Zähigkeit I",
        "description": "Erhöht die maximale HP um 5%.",
        "icon": "❤️",
        "levelRequirement": 1,
        "cost": 1,
        "dependencies": []
      },
      {
        "id": "skill_power_strike_1",
        "name": "Mächtiger Schlag I",
        "description": "Erhöht den physischen Schaden um 5.",
        "icon": "💪",
        "levelRequirement": 1,
        "cost": 1,
        "dependencies": []
      },
      {
        "id": "skill_toughness_2",
        "name": "Zähigkeit II",
        "description": "Erhöht die maximale HP um weitere 10%.",
        "icon": "💖",
        "levelRequirement": 3,
        "cost": 1,
        "dependencies": ["skill_toughness_1"]
      },
      {
        "id": "skill_power_strike_2",
        "name": "Mächtiger Schlag II",
        "description": "Erhöht den physischen Schaden um weitere 10.",
        "icon": "💥",
        "levelRequirement": 3,
        "cost": 2,
        "dependencies": ["skill_power_strike_1"]
      },
      {
        "id": "skill_whirlwind",
        "name": "Wirbelwind",
        "description": "Schaltet eine neue AoE-Fähigkeit frei.",
        "icon": "🌪️",
        "levelRequirement": 5,
        "cost": 3,
        "dependencies": ["skill_power_strike_2"]
      },
      {
        "id": "skill_unwavering_defense",
        "name": "Unerschütterliche Verteidigung",
        "description": "Erhöht die Verteidigung um 15.",
        "icon": "🛡️",
        "levelRequirement": 5,
        "cost": 2,
        "dependencies": ["skill_toughness_2"]
      }
    ]</script>
    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signOut, deleteUser } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, where, onSnapshot, serverTimestamp, doc, updateDoc, deleteDoc, increment, setDoc, getDoc, writeBatch, getDocs, deleteField, runTransaction, arrayUnion, arrayRemove, Timestamp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore.js";

        // --- Global Click Rate Limiter ---
        let lastClickTime = 0;
        const CLICK_RATE_LIMIT = 80; // 80ms

        window.addEventListener('click', (e) => {
            const now = Date.now();
            if (now - lastClickTime < CLICK_RATE_LIMIT) {
                e.preventDefault();
                e.stopPropagation();
                return;
            }
            lastClickTime = now;
        }, true);

        // --- Configuration ---
        const rarityTiers = {
            common: { name: 'Gewöhnlich', color: 'text-gray-300' },
            magic: { name: 'Magisch', color: 'text-green-400' },
            rare: { name: 'Selten', color: 'text-blue-400' },
            uniq: { name: 'Einzigartig', color: 'text-yellow-400' },
            legendary: { name: 'Legendär', color: 'text-orange-500' },
            epic: { name: 'Episch', color: 'text-purple-500' }
        };

        const rarityColors = {
            common: 'border-gray-500',
            magic: 'border-green-500',
            rare: 'border-blue-500',
            uniq: 'border-yellow-500',
            legendary: 'border-orange-500',
            epic: 'border-purple-500'
        };

        const itemDatabase = [
          { id: 'potion_hp_small', name: 'Heiltrank', icon: '🧪', type: 'consumable', slot: 'consumable', rarity: 'common', effect: { type: 'heal', amount: 50 }, baseStats: {} },
          { id: 'potion_mana_small', name: 'Manatrank', icon: '💧', type: 'consumable', slot: 'consumable', rarity: 'common', effect: { type: 'mana', amount: 30 }, baseStats: {} },
          { id: 'sword_common', name: 'Kurzschwert', icon: '🗡️', type: 'weapon', slot: 'weapon1', rarity: 'common', bonuses: { strength: 10 }, baseStats: { physDmg: 12, eleDmg: 0 } },
          { id: 'offhand_sword', name: 'Linkhand-Schwert', icon: '🗡️', type: 'weapon', slot: 'weapon2', rarity: 'common', bonuses: { agility: 5 }, baseStats: { physDmg: 8, eleDmg: 0 } },
          { id: 'claymore_common', name: 'Großer Zweihänder', icon: '⚔️', type: 'weapon', rarity: 'magic', bonuses: { strength: 25, vitality: 5 }, slot: 'weapon1', hands: 2, baseStats: { physDmg: 25, eleDmg: 0 } },
          { id: 'starter_set_chest', name: 'Starter-Rüstung', icon: '👕', type: 'armor', slot: 'chest', rarity: 'common', bonuses: { vitality: 3, strength: 3 }, baseStats: { armor: 10, eleRes: 2 } },
          { id: 'starter_set_legs', name: 'Starter-Hose', icon: '👖', type: 'armor', slot: 'legs', rarity: 'common', bonuses: { vitality: 2 }, baseStats: { armor: 6, eleRes: 1 } },
          { id: 'starter_set_head', name: 'Starter-Helm', icon: '🎓', type: 'armor', slot: 'head', rarity: 'common', bonuses: { int: 2 }, baseStats: { armor: 4, eleRes: 1 } },
          { id: 'starter_set_feet', name: 'Starter-Schuhe', icon: '👟', type: 'armor', slot: 'feet', rarity: 'common', bonuses: { agility: 2 }, baseStats: { armor: 3, eleRes: 1 } },
          { id: 'starter_set_hands', name: 'Starter-Handschuhe', icon: '🧤', type: 'armor', slot: 'hands', rarity: 'common', bonuses: { strength: 1 }, baseStats: { armor: 2, eleRes: 1 } },
          { id: 'starter_set_ring1', name: 'Starter-Ring', icon: '💍', type: 'armor', slot: 'ring1', rarity: 'common', bonuses: { luck: 5 } , baseStats: {} },
          { id: 'starter_set_ring2', name: 'Starter-Ring', icon: '💍', type: 'armor', slot: 'ring2', rarity: 'common', bonuses: { luck: 5 } , baseStats: {} },
          { id: 'starter_set_weapon', name: 'Starter-Dolch', icon: '🔪', type: 'weapon', slot: 'weapon1', rarity: 'common', bonuses: { agility: 3 }, baseStats: { physDmg: 5, eleDmg: 0 } },
          { id: 'starter_set_amulet', name: 'Starter-Amulett', icon: '🧿', type: 'armor', slot: 'amulet', rarity: 'common', bonuses: { luck: 2 }, baseStats: {} },
          { id: 'starter_set_bracers', name: 'Starter-Armschienen', icon: '💪', type: 'armor', slot: 'bracers', rarity: 'common', bonuses: { strength: 1 }, baseStats: { armor: 1 } },
          { id: 'starter_set_tool1', name: 'Angelrute', icon: '🎣', type: 'tool', slot: 'tool1', rarity: 'common', bonuses: {}, baseStats: {} },
          { id: 'starter_set_tool2', name: 'Spitzhacke', icon: '⛏️', type: 'tool', slot: 'tool2', rarity: 'common', bonuses: {}, baseStats: {} },
          { id: 'spell_fireball', name: 'Feuerball', icon: '🔥', type: 'spell', slot: 'spell', rarity: 'magic', effect: { type: 'damage', amount: 50 }, baseStats: {} },
          { id: 'pet_rock', name: 'Rocky', icon: '🪨', type: 'pet', rarity: 'common', element: 'Erde', baseStats: { vitality: 5 }, skills: ['Steinschlag', 'Härtner', 'Einigeln'] },
          { id: 'pet_slime', name: 'Slimey', icon: '💧', type: 'pet', rarity: 'common', element: 'Wasser', baseStats: { int: 5 }, skills: ['Blubber', 'Säure', 'Teilen'] },
          { id: 'pet_bat', name: 'Batty', icon: '🦇', type: 'pet', rarity: 'magic', element: 'Schatten', baseStats: { agility: 5 }, skills: ['Biss', 'Schrei', 'Blutsauger'] },
          { id: 'pet_dragon', name: 'Drago', icon: '🐉', type: 'pet', rarity: 'epic', element: 'Feuer', baseStats: { strength: 10, vitality: 5 }, skills: ['Feueratem', 'Flügelschlag', 'Drachenwut'] },
          { id: 'pet_sparky', name: 'Sparky', icon: '⚡️', type: 'pet', rarity: 'common', element: 'Elektro', baseStats: { agility: 3 }, skills: ['Tackle', 'Funkenschlag', 'Donnerwelle'] },
          { id: 'pet_blaze', name: 'Blaze', icon: '🔥', type: 'pet', rarity: 'rare', element: 'Feuer', baseStats: { strength: 5, vitality: 2 }, skills: ['Glut', 'Feuerwirbel', 'Rauchwolke'] },
          { id: 'pet_frosty', name: 'Frosty', icon: '❄️', type: 'pet', rarity: 'rare', element: 'Eis', baseStats: { int: 5, vitality: 2 }, skills: ['Eissplitter', 'Froststrahl', 'Nebel'] },
          { id: 'pet_shadow', name: 'Shadow', icon: '🌑', type: 'pet', rarity: 'epic', element: 'Dunkel', baseStats: { strength: 4, agility: 4, int: 4 }, skills: ['Schattenstoß', 'Dunkelklaue', 'Verfolgung'] },
          { id: 'test_sword_common_1h', name: 'Rostiges Schwert', icon: '🗡️', type: 'weapon', slot: 'weapon1', rarity: 'common', bonuses: { strength: 1 }, baseStats: { physDmg: 5 } },
          { id: 'test_axe_magic_1h', name: 'Verzauberte Axt', icon: '🪓', type: 'weapon', slot: 'weapon1', rarity: 'magic', bonuses: { strength: 3, vitality: 2 }, baseStats: { physDmg: 8, eleDmg: 3 } },
          { id: 'test_mace_rare_1h', name: 'Seltener Streitkolben', icon: '🔨', type: 'weapon', slot: 'weapon1', rarity: 'rare', bonuses: { strength: 8, vitality: 5 }, baseStats: { physDmg: 15 } },
          { id: 'test_greatsword_uniq_2h', name: 'Einzigartiger Zweihänder', icon: '⚔️', type: 'weapon', slot: 'weapon1', hands: 2, rarity: 'uniq', bonuses: { strength: 15, agility: -5, vitality: 10 }, baseStats: { physDmg: 35 } },
          { id: 'test_spear_legendary_2h', name: 'Legendärer Speer', icon: '🔱', type: 'weapon', slot: 'weapon1', hands: 2, rarity: 'legendary', bonuses: { strength: 20, agility: 15, luck: 10 }, baseStats: { physDmg: 40, eleDmg: 15 } },
          { id: 'test_daggers_epic_1h', name: 'Epische Dolche', icon: '🔪', type: 'weapon', slot: 'weapon2', rarity: 'epic', bonuses: { agility: 25, strength: 5 }, baseStats: { physDmg: 22 } },
        ];

        const achievementDatabase = [
            { id: 'quests_1', name: 'Erste Schritte', description: 'Schließe deine erste Quest ab.', icon: '📜', condition: { type: 'questsCompleted', value: 1 }, reward: { type: 'xp', amount: 25 } },
            { id: 'quests_10', name: 'Fleißiger Arbeiter', description: 'Schließe 10 Quests ab.', icon: '📚', condition: { type: 'questsCompleted', value: 10 }, reward: { type: 'xp', amount: 100 } },
            { id: 'level_5', name: 'Aufstrebend', description: 'Erreiche Level 5.', icon: '⭐', condition: { type: 'level', value: 5 }, reward: { type: 'statPoints', amount: 2 } },
            { id: 'pomodoro_1', name: 'Zeitmanagement-Anfänger', description: 'Benutze den Pomodoro Timer einmal.', icon: '🍅', condition: { type: 'pomodorosCompleted', value: 1 }, reward: { type: 'xp', amount: 15 } }
        ];

        const vitalityToHpCaps = [ { threshold: 0, multiplier: 10 }, { threshold: 10, multiplier: 15 }, { threshold: 20, multiplier: 20 }];
        const intToManaMultiplier = 8;
        const staminaToValueMultiplier = 10;
        const baseMana = 20;
        const availableTags = ['Arbeit', 'Privat', 'Lernen', 'Haushalt', 'Sport'];
        const weekDays = ['Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa', 'So'];
        const defaultSlotTexts = {
            weapon1: 'Waffe 1', weapon2: 'Waffe 2', tool1: 'Werkzeug 1', tool2: 'Werkzeug 2',
            head: 'Kopf', amulet: 'Amulett', chest: 'Brust', bracers: 'Armschienen',
            hands: 'Hände', legs: 'Beine', feet: 'Füße', ring1: 'Ring 1', ring2: 'Ring 2'
        };
        
        const firebaseConfig = { apiKey: "AIzaSyBJgfy6sgA5HyNhFZDuzAaMCi16UyDtazA", authDomain: "gamification-core.firebaseapp.com", projectId: "gamification-core", storageBucket: "gamification-core.appspot.com", messagingSenderId: "187541389621", appId: "1:187541389621:web:7d9acbd0ea15a953188c7c", measurementId: "G-GG9Y71NFYG" };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // DOM Elements
        const authView = document.getElementById('auth-view');
        const appView = document.getElementById('app-view');
        const loginBtn = document.getElementById('login-btn');
        const logoutBtn = document.getElementById('logout-btn');
        const characterNameDisplay = document.getElementById('character-name');
        const characterLevelDisplay = document.getElementById('character-level');
        const characterAchievementsDisplay = document.getElementById('character-achievements-display');
        const statPointsContainer = document.getElementById('stat-points-container');
        const statPointsDisplayFooter = document.getElementById('stat-points-display-footer');
        
        const hpBarFill = document.getElementById('hp-bar-fill');
        const hpBarText = document.getElementById('hp-bar-text');
        const manaBarFill = document.getElementById('mana-bar-fill');
        const manaBarText = document.getElementById('mana-bar-text');
        const staminaBarFill = document.getElementById('stamina-bar-fill');
        const staminaBarText = document.getElementById('stamina-bar-text');
        const xpBarProgress = document.getElementById('xp-bar-progress');
        const xpCurrentInLevel = document.getElementById('xp-current-in-level');
        const xpNeededForLevel = document.getElementById('xp-needed-for-level');

        const goldAmountDisplay = document.getElementById('gold-amount');
        const silverAmountDisplay = document.getElementById('silver-amount');
        const bronzeAmountDisplay = document.getElementById('bronze-amount');
        const crystalsAmountDisplay = document.getElementById('crystals-amount');

        const useHpPotionBtn = document.getElementById('use-hp-potion-btn');
        const useManaPotionBtn = document.getElementById('use-mana-potion-btn');

        const addTodoForm = document.getElementById('add-todo-form');
        const todoInput = document.getElementById('todo-input');
        const todoPriorityInput = document.getElementById('todo-priority');
        const todoTaskTypeInput = document.getElementById('todo-task-type');
        const todoParentProjectContainer = document.getElementById('todo-parent-project-container');
        const todoParentProjectInput = document.getElementById('todo-parent-project');
        const todoDeadlineInput = document.getElementById('todo-deadline');
        const todoTagsContainer = document.getElementById('todo-tags-container');
        const todoDetailsInput = document.getElementById('todo-details');
        const toggleDetailsBtn = document.getElementById('toggle-details-btn');
        const detailsToggleContent = document.getElementById('details-toggle-content');
        const todoRepeatCheckbox = document.getElementById('todo-repeat');
        const todoRepeatDaysContainer = document.getElementById('todo-repeat-days-container');
        const todoStartTimeInput = document.getElementById('todo-start-time');
        const todoListContainer = document.getElementById('todo-list');
        const focusQuestContainer = document.getElementById('focus-quest-container');
        
        const notificationArea = document.getElementById('notification-area');
        const characterStatsContainer = document.getElementById('ui-block-character-stats');

        const newQuestModal = document.getElementById('new-quest-modal');
        const myQuestsModal = document.getElementById('my-quests-modal');
        const journalModal = document.getElementById('journal-modal');
        const journalList = document.getElementById('journal-list');
        const equipmentModal = document.getElementById('equipment-modal');
        const inventoryModal = document.getElementById('inventory-modal');
        const achievementsModal = document.getElementById('achievements-modal');
        const achievementsList = document.getElementById('achievements-list');
        const pomodoroModal = document.getElementById('pomodoro-modal');
        const ganttChartContainer = document.getElementById('gantt-chart-container');
        const ganttControls = document.getElementById('gantt-controls');
        const deleteConfirmModal = document.getElementById('delete-confirm-modal');
        const deleteConfirmBtn = document.getElementById('delete-confirm-btn');
        const deleteCancelBtn = document.getElementById('delete-cancel-btn');
        const deleteConfirmText = document.getElementById('delete-confirm-text');
        const petsModal = document.getElementById('pets-modal');
        const activePetsSidebar = document.getElementById('active-pets-sidebar');
        const skillTreeModal = document.getElementById('skill-tree-modal');
        const skillTreeContainer = document.getElementById('skill-tree-container');
        const skillPointsDisplay = document.getElementById('skill-points-display');


        const menuBtnNewQuest = document.getElementById('menu-btn-new-quest');
        const menuBtnMyQuests = document.getElementById('menu-btn-my-quests');
        const menuBtnJournal = document.getElementById('menu-btn-journal');
        const menuBtnEquipment = document.getElementById('menu-btn-equipment');
        const menuBtnInventory = document.getElementById('menu-btn-inventory');
        const menuBtnAchievements = document.getElementById('menu-btn-achievements');
        const menuBtnPets = document.getElementById('menu-btn-pets');
        const openSkillsBtn = document.getElementById('open-skills-btn');
        
        const equipmentSlotsContainer = document.getElementById('equipment-slots-container');
        const equipmentItemDetails = document.getElementById('equipment-item-details');
        const inventoryListContainer = document.getElementById('inventory-list-container');
        const inventoryItemDetails = document.getElementById('inventory-item-details');
        const inventoryPagePrev = document.getElementById('inventory-page-prev');
        const inventoryPageNext = document.getElementById('inventory-page-next');
        const inventoryPageInfo = document.getElementById('inventory-page-info');
        
        const derivedStatPhysDmg = document.getElementById('derived-stat-phys-dmg');
        const derivedStatDef = document.getElementById('derived-stat-def');
        const derivedStatDodge = document.getElementById('derived-stat-dodge');
        const derivedStatEleDmg = document.getElementById('derived-stat-ele-dmg');

        // Pomodoro Timer Elements
        const timerDisplay = document.getElementById('timer-display');
        const timerModeDisplay = document.getElementById('timer-mode-display');
        const timerStartBtn = document.getElementById('timer-start-btn');
        const timerPauseBtn = document.getElementById('timer-pause-btn');
        const timerResetBtn = document.getElementById('timer-reset-btn');
        const timerSelectBtns = document.querySelectorAll('.timer-select-btn');

        // Break Timer Elements
        const breakPopupModal = document.getElementById('break-popup-modal');
        const breakTimerDisplay = document.getElementById('break-timer-display');
        const extendBreak5Btn = document.getElementById('extend-break-5-btn');
        const extendBreak25Btn = document.getElementById('extend-break-25-btn');
        const closeBreakPopupBtn = document.getElementById('close-break-popup-btn');
        const minimizedBreakTimer = document.getElementById('minimized-break-timer');
        const minimizedBreakTimerDisplay = document.getElementById('minimized-break-timer-display');
        const postBreakModal = document.getElementById('post-break-modal');
        const continueQuestBtn = document.getElementById('continue-quest-btn');

        // Pet Modal Elements
        const petsInventoryList = document.getElementById('pets-inventory-list');
        const petsDetailsView = document.getElementById('pets-details-view');
        const petsPagePrev = document.getElementById('pets-page-prev');
        const petsPageNext = document.getElementById('pets-page-next');
        const petsPageInfo = document.getElementById('pets-page-info');
        const petFilterElement = document.getElementById('pet-filter-element');
        const petFilterRarity = document.getElementById('pet-filter-rarity');

        let todosUnsubscribe = null;
        let userProfileUnsubscribe = null;
        let inventoryUnsubscribe = null;
        let journalUnsubscribe = null;
        let localQuests = [];
        let ganttBreaks = [];
        let currentUserProfile = {};
        let currentItemFound = null;
        let itemToDeleteId = null;
        let petToReleaseId = null;
        let inventoryCurrentPage = 1;
        let inventorySortCategory = 'all';
        const inventoryItemsPerPage = 6;
        let openModals = [];
        let focusedQuestId = null;

        // Pet System State
        let petsCurrentPage = 1;
        const petsItemsPerPage = 8;
        let comparedActivePetSlotIndex = 0;
        let selectedInventoryPetId = null;
        let petFilters = { element: 'all', rarity: 'all' };
        
        // Skill System State
        let skillsData = [];
        let selectedSkillId = null;
        
        // Dummy function for module integration
        function startSiedlerRisikoGame(userData) {
            console.log("MODUL-DUMMY: 'Siedler Risiko Mix' gestartet mit den Daten von:", userData);
            // Hier wird später die Logik des Moduls aufgerufen.
        }

        // Pomodoro Timer State
        let timerInterval = null;
        let timeLeftInSeconds = 25 * 60;
        let defaultTime = 25 * 60;
        let isTimerPaused = true;
        
        // Focus Timer State
        let focusTimer = {
            interval: null,
            timeLeft: 0,
            totalWorkTimeForQuest: 0,
            isPaused: true,
            isRunning: false,
            questId: null
        };
        
        // Break Timer State
        let breakTimer = {
            interval: null,
            timeLeft: 0,
            isPaused: true,
        };
        
        // --- Modal & Window Management ---
        const allModals = document.querySelectorAll('.modal');
        
        function arrangeModals() {
            const visibleModals = Array.from(allModals).filter(m => !m.classList.contains('hidden'));
            visibleModals.forEach((modal, index) => {
                modal.style.left = `calc(50% - ${modal.offsetWidth / 2}px + ${index * 40}px)`;
                modal.style.top = `calc(25% + ${index * 40}px)`;
                modal.style.zIndex = 40 + index;
            });
        }
        
        const toggleModal = (modal) => {
            modal.classList.toggle('hidden');
            arrangeModals();
        };

        menuBtnNewQuest.addEventListener('click', () => {
            resetQuestWizard();
            toggleModal(newQuestModal);
        });
        menuBtnMyQuests.addEventListener('click', () => toggleModal(myQuestsModal));
        menuBtnJournal.addEventListener('click', () => toggleModal(journalModal));
        menuBtnEquipment.addEventListener('click', () => toggleModal(equipmentModal));
        menuBtnInventory.addEventListener('click', () => toggleModal(inventoryModal));
        menuBtnAchievements.addEventListener('click', () => toggleModal(achievementsModal));
        document.getElementById('pomodoro-modal')?.addEventListener('click', () => toggleModal(pomodoroModal));
        menuBtnPets.addEventListener('click', () => {
            selectedInventoryPetId = null;
            comparedActivePetSlotIndex = 0;
            renderPets(currentUserProfile);
            toggleModal(petsModal);
        });
        
        allModals.forEach(modal => {
            modal.querySelector('.modal-close-btn')?.addEventListener('click', () => modal.classList.add('hidden'));
            
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            const header = modal.querySelector('.modal-header');
            if (header) {
                header.onmousedown = (e) => {
                    e.preventDefault();
                    pos3 = e.clientX;
                    pos4 = e.clientY;
                    document.onmouseup = () => { document.onmouseup = null; document.onmousemove = null; };
                    document.onmousemove = (e) => {
                        e.preventDefault();
                        pos1 = pos3 - e.clientX;
                        pos2 = pos4 - e.clientY;
                        pos3 = e.clientX;
                        pos4 = e.clientY;
                        modal.style.top = (modal.offsetTop - pos2) + "px";
                        modal.style.left = (modal.offsetLeft - pos1) + "px";
                    };
                };
            }
        });
        
        // Collapsible Menu Logic
        document.querySelectorAll('.menu-section-header').forEach(header => {
            header.addEventListener('click', () => {
                const content = header.nextElementSibling;
                content.classList.toggle('hidden');
            });
        });

        // Keyboard shortcuts
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const visibleModals = Array.from(allModals).filter(m => !m.classList.contains('hidden'));
                if (visibleModals.length > 0) {
                    visibleModals[visibleModals.length - 1].classList.add('hidden'); // Close the top-most modal
                }
            }
            if (e.key === 'Enter') {
                if (!itemFoundModal.classList.contains('hidden') && deleteConfirmModal.classList.contains('hidden')) {
                    modalKeepBtn.click();
                }
            }
        });


        // --- Authentication ---
        onAuthStateChanged(auth, (user) => {
            if (user) {
                authView.classList.add('hidden');
                appView.classList.remove('hidden');
                getUserProfile(user.uid);
                fetchTodos(user.uid);
                listenToInventory(user.uid);
                listenToJournal(user.uid);
                 setInterval(checkGanttAutoFocus, 60000); // Check every minute for auto-focus
            } else {
                authView.classList.remove('hidden');
                appView.classList.add('hidden');
                if (todosUnsubscribe) todosUnsubscribe();
                if (userProfileUnsubscribe) userProfileUnsubscribe();
                if (inventoryUnsubscribe) inventoryUnsubscribe();
                if (journalUnsubscribe) journalUnsubscribe();
            }
        });

        loginBtn.addEventListener('click', () => signInAnonymously(auth).catch(console.error));
        logoutBtn.addEventListener('click', async () => {
            const user = auth.currentUser;
            if (user) {
                await deleteUserData(user.uid);
            } else {
                 signOut(auth).catch(console.error);
            }
        });
        
        async function deleteUserData(userId) {
            try {
                allModals.forEach(modal => modal.classList.add('hidden'));
                
                const userDocRef = doc(db, 'users', userId);
                const subcollections = ['inventory', 'journal'];
                const deletePromises = [];

                for (const sub of subcollections) {
                    const subRef = collection(db, 'users', userId, sub);
                    const snapshot = await getDocs(subRef);
                    const batch = writeBatch(db);
                    snapshot.forEach(doc => batch.delete(doc.ref));
                    deletePromises.push(batch.commit());
                }
        
                const todosQuery = query(collection(db, 'todos'), where("userId", "==", userId));
                const todosSnapshot = await getDocs(todosQuery);
                const todosDeleteBatch = writeBatch(db);
                todosSnapshot.forEach(doc => todosDeleteBatch.delete(doc.ref));
                deletePromises.push(todosDeleteBatch.commit());

                await Promise.all(deletePromises);
                await deleteDoc(userDocRef);
                await deleteUser(auth.currentUser);

                showNotification("Test-Account und Daten gelöscht.");
            } catch (error) {
                console.error("Error deleting user data:", error);
                signOut(auth).catch(console.error);
            }
        }
        
        // --- Calculation Functions ---
        function calculateMaxHp(vitality) {
            let maxHp = 100;
            let pointsToCalculate = vitality;
            for (let i = vitalityToHpCaps.length - 1; i >= 0; i--) {
                const cap = vitalityToHpCaps[i];
                if (pointsToCalculate > cap.threshold) {
                    maxHp += (pointsToCalculate - cap.threshold) * cap.multiplier;
                    pointsToCalculate = cap.threshold;
                }
            }
            return maxHp;
        }
        const calculateMaxMana = (intelligence) => baseMana + (intelligence * intToManaMultiplier);
        const calculateMaxStamina = (stamina) => (stamina * staminaToValueMultiplier);

        function processQuestDrop(quest) {
            const luck = currentUserProfile.stats?.luck || 10;
            const priority = quest.priority;
            
            // 1. Calculate if a drop occurs at all
            const baseChance = 0.1;
            const priorityMultipliers = { 'Leicht': 1.0, 'Mittel': 1.2, 'Schwer': 1.5 };
            const multiplier = priorityMultipliers[priority] || 1.0;
            const finalChance = Math.min((baseChance + (luck * 0.01)) * multiplier, 1.0);

            if (Math.random() > finalChance) return; // No drop

            // 2. If drop occurs, determine rarity
            const luckFactor = luck / 100; // e.g., 10 luck = 0.1
            const rarityChances = {
                epic: 0.001 + (luckFactor * 0.005),       // 0.1% base chance
                legendary: 0.005 + (luckFactor * 0.01),   // 0.5% base chance
                uniq: 0.025 + (luckFactor * 0.05),        // 2.5% base chance
                rare: 0.1 + (luckFactor * 0.1),           // 10% base chance
                magic: 0.25 + (luckFactor * 0.1),         // 25% base chance
                common: 1.0                               // Remainder
            };
            
            const roll = Math.random();
            let chosenRarity = 'common';
            if (roll < rarityChances.epic) chosenRarity = 'epic';
            else if (roll < rarityChances.legendary) chosenRarity = 'legendary';
            else if (roll < rarityChances.uniq) chosenRarity = 'uniq';
            else if (roll < rarityChances.rare) chosenRarity = 'rare';
            else if (roll < rarityChances.magic) chosenRarity = 'magic';

            // 3. Find an item of that rarity
            const possibleItems = itemDatabase.filter(item => item.rarity === chosenRarity && item.type !== 'pet');
            if (possibleItems.length > 0) {
                const droppedItem = possibleItems[Math.floor(Math.random() * possibleItems.length)];
                showItemFoundPopup(droppedItem);
            }
        }

        // --- Currency Display Logic ---
        function updateCurrencyDisplay(currencyData, crystalsData) {
            const totalBronzeFromObject = (currencyData?.bronze || 0) + (currencyData?.silver || 0) * 100 + (currencyData?.gold || 0) * 10000;
            const crystals = crystalsData || 0;
            
            const gold = Math.floor(totalBronzeFromObject / 10000);
            let remaining = totalBronzeFromObject % 10000;
            
            const silver = Math.floor(remaining / 100);
            const bronze = remaining % 100;

            goldAmountDisplay.textContent = gold;
            silverAmountDisplay.textContent = silver;
            bronzeAmountDisplay.textContent = bronze;
            crystalsAmountDisplay.textContent = crystals;
        }

        // --- CENTRAL CHARACTER SHEET UPDATE ---
        const updateCharacterSheet = (userData) => {
            if (!userData) return;

            // 1. Berechne die kombinierten Stats von Charakter und Ausrüstung.
            // Dies sind die einzigen Werte, die den Charakter beeinflussen.
            // Pet-Boni werden hier absichtlich VOLLSTÄNDIG ignoriert.
            const totalCharacterStats = { ...(userData.stats || {}) };
            if (userData.equipment) {
                Object.values(userData.equipment).forEach(item => {
                    if (item && item.bonuses) {
                        Object.entries(item.bonuses).forEach(([stat, value]) => {
                            totalCharacterStats[stat] = (totalCharacterStats[stat] || 0) + value;
                        });
                    }
                });
            }

            // 2. UI-UPDATE
            characterNameDisplay.textContent = auth.currentUser?.uid.substring(0, 8);
            characterLevelDisplay.textContent = userData.level || 1;

            characterAchievementsDisplay.innerHTML = '';
            if (userData.displayedAchievements) {
                userData.displayedAchievements.forEach(achId => {
                    const achievement = achievementDatabase.find(a => a.id === achId);
                    if (achievement) {
                        const iconEl = document.createElement('span');
                        iconEl.textContent = achievement.icon;
                        iconEl.title = achievement.name;
                        characterAchievementsDisplay.appendChild(iconEl);
                    }
                });
            }

            // BENUTZE AUSSCHLIESSLICH totalCharacterStats für HP, Mana, Ausdauer
            const maxHp = calculateMaxHp(totalCharacterStats.vitality || 0);
            const currentHp = Math.min(userData.hp?.current || maxHp, maxHp);
            hpBarFill.style.width = `${maxHp > 0 ? (currentHp / maxHp) * 100 : 0}%`;
            hpBarText.textContent = `${Math.round(currentHp)} / ${maxHp}`;

            const maxMana = calculateMaxMana(totalCharacterStats.int || 0);
            const currentMana = Math.min(userData.mana?.current || maxMana, maxMana);
            manaBarFill.style.width = `${maxMana > 0 ? (currentMana / maxMana) * 100 : 0}%`;
            manaBarText.textContent = `${Math.round(currentMana)} / ${maxMana}`;
            
            const maxStamina = calculateMaxStamina(totalCharacterStats.stamina || 0);
            const currentStamina = Math.min(userData.stamina?.current || maxStamina, maxStamina);
            staminaBarFill.style.width = `${maxStamina > 0 ? (currentStamina / maxStamina) * 100 : 0}%`;
            staminaBarText.textContent = `${Math.round(currentStamina)} / ${maxStamina}`;

            const currentLevel = userData.level || 1;
            const getXpForLevel = (level) => (level - 1) * 100;
            const xpNeededInTotal = getXpForLevel(currentLevel + 1) - getXpForLevel(currentLevel);
            const xpProgressInLevel = (userData.xp || 0) - getXpForLevel(currentLevel);
            xpBarProgress.style.width = `${xpNeededInTotal > 0 ? (xpProgressInLevel / xpNeededInTotal) * 100 : 0}%`;
            xpCurrentInLevel.textContent = xpProgressInLevel;
            xpNeededForLevel.textContent = xpNeededInTotal;

            // BENUTZE AUSSCHLIESSLICH totalCharacterStats für die sichtbare Attribut-Anzeige
            Object.keys(userData.stats || {}).forEach(stat => {
                const el = document.getElementById(`stat-${stat}`);
                if (el) el.textContent = totalCharacterStats[stat] || 0;
            });

            const currentStatPoints = userData.statPoints || 0;
            statPointsDisplayFooter.textContent = currentStatPoints;
            statPointsContainer.classList.toggle('hidden', currentStatPoints <= 0);
            document.querySelectorAll('.stat-increase-btn').forEach(el => {
                const amount = parseInt(el.dataset.amount || '1', 10);
                el.classList.toggle('hidden', currentStatPoints < amount);
            });

            // BENUTZE AUSSCHLIESSLICH totalCharacterStats für abgeleitete Kampfwerte
            derivedStatPhysDmg.textContent = ((totalCharacterStats.strength || 0) * 0.5).toFixed(1);
            derivedStatDef.textContent = ((totalCharacterStats.strength || 0) * 0.1).toFixed(1);
            derivedStatDodge.textContent = `${((totalCharacterStats.agility || 0) * 0.05).toFixed(1)}%`;
            derivedStatEleDmg.textContent = `${((totalCharacterStats.int || 0) * 0.05).toFixed(1)}`;

            // Equipment Modal UI aktualisieren
            document.querySelectorAll('.equipment-slot').forEach(slotEl => {
                const slotType = slotEl.dataset.slotType;
                const equippedItem = userData.equipment?.[slotType];
                if (equippedItem && equippedItem.id !== 'blocked_slot') {
                    slotEl.innerHTML = `<span class="text-4xl" title="${equippedItem.name}">${equippedItem.icon}</span>`;
                    slotEl.classList.remove('text-gray-400');
                    slotEl.dataset.itemId = equippedItem.docId || equippedItem.id;
                } else if (equippedItem && equippedItem.id === 'blocked_slot') {
                     slotEl.innerHTML = `<span>🚫</span>`;
                     slotEl.classList.add('bg-gray-700', 'blocked');
                     delete slotEl.dataset.itemId;
                } else {
                    const defaultText = defaultSlotTexts[slotType] || 'Slot';
                    slotEl.innerHTML = `<span>${defaultText}</span>`;
                    slotEl.classList.add('text-gray-400');
                    slotEl.classList.remove('bg-gray-700', 'blocked');
                    delete slotEl.dataset.itemId;
                }
            });

            renderActivePetsSidebar(userData);
            updateCurrencyDisplay(userData.currency, userData.crystals);
        };


        const getUserProfile = async (userId) => {
            const userDocRef = doc(db, 'users', userId);
            if (userProfileUnsubscribe) userProfileUnsubscribe();

            try {
                const docSnap = await getDoc(userDocRef);
                if (!docSnap.exists()) {
                    const batch = writeBatch(db);
                    const initialMaxHp = calculateMaxHp(10);
                    const initialMaxMana = calculateMaxMana(10);
                    const initialMaxStamina = calculateMaxStamina(10);

                    // 1. Define starter equipment
                    const defaultEquipment = {};
                    const starterItemMap = {
                        head: 'starter_set_head', chest: 'starter_set_chest', legs: 'starter_set_legs',
                        feet: 'starter_set_feet', hands: 'starter_set_hands', ring1: 'starter_set_ring1',
                        ring2: 'starter_set_ring2', weapon1: 'starter_set_weapon', weapon2: 'offhand_sword',
                        amulet: 'starter_set_amulet', bracers: 'starter_set_bracers',
                        tool1: 'starter_set_tool1', tool2: 'starter_set_tool2',
                    };

                    Object.entries(starterItemMap).forEach(([slot, itemId]) => {
                        const itemData = itemDatabase.find(i => i.id === itemId);
                        if (itemData) {
                            defaultEquipment[slot] = { ...itemData, docId: `starter_${slot}` };
                        }
                    });
                    
                    const starterPetIds = ['pet_rock', 'pet_sparky', 'pet_blaze', 'pet_frosty', 'pet_shadow'];
                    const starterPets = {};
                    starterPetIds.forEach(petId => {
                        const petData = itemDatabase.find(i => i.id === petId);
                        if (petData) {
                            const docId = `starter_${petId}`;
                            starterPets[docId] = { 
                                ...petData, 
                                docId,
                                level: 1,
                                xp: 0,
                                maxXp: 100,
                                currentStats: { ...(petData.baseStats || {}) }
                            };
                        }
                    });

                    // 2. Set the main user document
                    batch.set(userDocRef, {
                        xp: 0, level: 1, 
                        statPoints: 50,
                        skillPoints: 0,
                        questsCompleted: 0,
                        pomodorosCompleted: 0,
                        achievements: {},
                        displayedAchievements: [],
                        currency: { gold: 0, silver: 0, bronze: 250 },
                        skills: [],
                        crystals: 5,
                        hp: { current: initialMaxHp, max: initialMaxHp },
                        mana: { current: initialMaxMana, max: initialMaxMana },
                        stamina: { current: initialMaxStamina, max: initialMaxStamina },
                        stats: { vitality: 10, strength: 10, stamina: 10, agility: 10, int: 10, luck: 10 },
                        equipment: defaultEquipment,
                        pets: starterPets,
                        activePets: ['starter_pet_rock']
                    });

                    // 3. Add extra items to inventory (2H weapon, potions, and test weapons)
                    const testWeaponIds = ['test_sword_common_1h', 'test_axe_magic_1h', 'test_mace_rare_1h', 'test_greatsword_uniq_2h', 'test_spear_legendary_2h', 'test_daggers_epic_1h'];
                    const testWeapons = testWeaponIds.map(id => itemDatabase.find(i => i.id === id)).filter(Boolean);
                    
                    const itemsForInventory = [
                        itemDatabase.find(i => i.id === 'claymore_common'),
                        ...Array(3).fill(itemDatabase.find(i => i.id === 'potion_hp_small')),
                        ...Array(3).fill(itemDatabase.find(i => i.id === 'potion_mana_small')),
                        ...testWeapons
                    ].filter(Boolean);

                    const inventoryToAdd = {};
                    itemsForInventory.forEach(item => {
                        if (item.type === 'consumable') {
                            if (!inventoryToAdd[item.id]) {
                                inventoryToAdd[item.id] = {...item, quantity: 0};
                            }
                            inventoryToAdd[item.id].quantity += 1;
                        } else {
                            const newItemRef = doc(collection(db, 'users', userId, 'inventory'));
                            batch.set(newItemRef, {...item, quantity: 1});
                        }
                    });

                    Object.values(inventoryToAdd).forEach(item => {
                        const newItemRef = doc(collection(db, 'users', userId, 'inventory'));
                        batch.set(newItemRef, item);
                    });

                    await batch.commit();
                }
            } catch (error) { console.error("Error creating user profile:", error); }

            userProfileUnsubscribe = onSnapshot(userDocRef, (doc) => {
                currentUserProfile = doc.data();
                updateCharacterSheet(currentUserProfile);
                renderAchievements(currentUserProfile);
                if(!petsModal.classList.contains('hidden')) {
                    renderPets(currentUserProfile);
                }
                if (!skillTreeModal.classList.contains('hidden')) {
                    renderSkillTreeUI();
                }
            }, console.error);
        };
        
        characterStatsContainer.addEventListener('click', async (event) => {
             const target = event.target.closest('.stat-increase-btn');
            const userId = auth.currentUser?.uid;
            if (!userId || !target) return;
        
            const statToIncrease = target.dataset.stat;
            const amount = parseInt(target.dataset.amount || '1', 10);
            if ((currentUserProfile.statPoints || 0) < amount) return;
        
            const userDocRef = doc(db, 'users', userId);
            try {
                if (statToIncrease === 'vitality') {
                    const baseVitality = (await getDoc(userDocRef)).data().stats.vitality || 10;
                    let hpGained = 0;
                    for (let i = 0; i < amount; i++) hpGained += calculateMaxHp(baseVitality + i + 1) - calculateMaxHp(baseVitality + i);
                    await updateDoc(userDocRef, { statPoints: increment(-amount), 'stats.vitality': increment(amount), 'hp.current': increment(hpGained), 'hp.max': increment(hpGained) });
                } else if (statToIncrease === 'int') {
                    const manaGained = intToManaMultiplier * amount;
                    await updateDoc(userDocRef, { statPoints: increment(-amount), 'stats.int': increment(amount), 'mana.current': increment(manaGained), 'mana.max': increment(manaGained) });
                } else if (statToIncrease === 'stamina') {
                    const staminaGained = staminaToValueMultiplier * amount;
                    await updateDoc(userDocRef, { statPoints: increment(-amount), 'stats.stamina': increment(amount), 'stamina.current': increment(staminaGained), 'stamina.max': increment(staminaGained) });
                }
                else {
                    await updateDoc(userDocRef, { statPoints: increment(-amount), [`stats.${statToIncrease}`]: increment(amount) });
                }
            } catch (error) { console.error("Error updating stats:", error); }
        });

        // --- Skill System ---
        function openSkillTree() {
            if (skillsData.length === 0) {
                try {
                    const dataEl = document.getElementById('skills-data');
                    if (dataEl) skillsData = JSON.parse(dataEl.textContent);
                } catch (e) { console.error("Failed to parse skills data:", e); return; }
            }
            selectedSkillId = skillsData.length > 0 ? skillsData[0].id : null;
            renderSkillTreeUI();
            toggleModal(skillTreeModal);
        }

        function renderSkillTreeUI() {
            if (!currentUserProfile || !skillTreeModal) return;
            renderSkillListPanel();
            renderSkillDetailPanel();
        }

        function renderSkillListPanel() {
            const skillListPanel = document.getElementById('skill-list-panel');
            if (!skillListPanel) return;
            skillListPanel.innerHTML = '';
            
            const learnedSkills = currentUserProfile.skills || [];
            const availableSkillPoints = currentUserProfile.skillPoints || 0;

            skillsData.forEach(skill => {
                const isUnlocked = learnedSkills.includes(skill.id);
                const dependenciesMet = skill.dependencies.every(depId => learnedSkills.includes(depId));
                const canLearn = !isUnlocked &&
                                 currentUserProfile.level >= skill.levelRequirement &&
                                 availableSkillPoints >= skill.cost &&
                                 dependenciesMet;

                const skillNode = document.createElement('div');
                skillNode.className = 'skill-node';
                skillNode.dataset.skillId = skill.id;

                let stateClass = 'skill-node--locked';
                if (isUnlocked) stateClass = 'skill-node--unlocked';
                else if (canLearn) stateClass = 'skill-node--learnable';
                skillNode.classList.add(stateClass);
                
                if (skill.id === selectedSkillId) {
                    skillNode.classList.add('selected');
                }

                skillNode.innerHTML = `
                    <div class="skill-icon">${skill.icon || '❓'}</div>
                    <span class="text-sm font-semibold">${skill.name}</span>
                `;
                skillListPanel.appendChild(skillNode);
            });
        }
        
        function renderSkillDetailPanel() {
            const skillDetailPanel = document.getElementById('skill-detail-panel');
            if (!skillDetailPanel) return;

            skillPointsDisplay.textContent = currentUserProfile.skillPoints || 0;

            const skill = skillsData.find(s => s.id === selectedSkillId);
            if (!skill) {
                skillDetailPanel.innerHTML = '<p class="text-center text-gray-400 m-auto">Wähle einen Skill aus der Liste aus.</p>';
                return;
            }
            
            const learnedSkills = currentUserProfile.skills || [];
            const isUnlocked = learnedSkills.includes(skill.id);
            const dependenciesMet = skill.dependencies.every(depId => learnedSkills.includes(depId));
            const levelMet = currentUserProfile.level >= skill.levelRequirement;
            const pointsMet = (currentUserProfile.skillPoints || 0) >= skill.cost;
            const canLearn = !isUnlocked && dependenciesMet && levelMet && pointsMet;

            let requirementsHtml = `
                <ul class="text-sm text-gray-400 mt-4 space-y-1">
                    <li class="${pointsMet ? 'text-green-400' : 'text-red-400'}">Kosten: ${skill.cost} Punkt(e)</li>
                    <li class="${levelMet ? 'text-green-400' : 'text-red-400'}">Benötigtes Level: ${skill.levelRequirement}</li>
                    ${skill.dependencies.length > 0 ? `<li class="${dependenciesMet ? 'text-green-400' : 'text-red-400'}">Benötigt: ${skill.dependencies.map(depId => skillsData.find(s => s.id === depId)?.name || 'Unbekannt').join(', ')}</li>` : ''}
                </ul>
            `;

            skillDetailPanel.innerHTML = `
                <div class="text-center">
                    <span class="text-6xl">${skill.icon || '❓'}</span>
                    <h3 class="text-2xl font-bold mt-2">${skill.name}</h3>
                </div>
                <p class="text-gray-300 mt-4 text-center">${skill.description}</p>
                <div class="mt-auto pt-4 border-t border-gray-600">
                    <h4 class="font-semibold text-gray-200 mb-2">Voraussetzungen</h4>
                    ${requirementsHtml}
                    <button id="learn-skill-btn" 
                            data-skill-id="${skill.id}"
                            class="w-full mt-4 py-2 px-4 font-bold rounded-lg transition-colors 
                                   ${canLearn ? 'bg-green-600 hover:bg-green-500' : 'bg-gray-600 cursor-not-allowed'}"
                            ${canLearn ? '' : 'disabled'}>
                        ${isUnlocked ? 'Bereits erlernt' : 'Skill erlernen'}
                    </button>
                </div>
            `;
        }
        
        async function learnSkill(skillId) {
            const userId = auth.currentUser?.uid;
            if (!userId || !skillId) return;

            const skill = skillsData.find(s => s.id === skillId);
            if (!skill) return;

            // Re-validate just before database write
            const learnedSkills = currentUserProfile.skills || [];
            const isUnlocked = learnedSkills.includes(skill.id);
            const dependenciesMet = skill.dependencies.every(depId => learnedSkills.includes(depId));
            const levelMet = currentUserProfile.level >= skill.levelRequirement;
            const pointsMet = (currentUserProfile.skillPoints || 0) >= skill.cost;

            if (isUnlocked || !dependenciesMet || !levelMet || !pointsMet) {
                showNotification("Voraussetzungen nicht erfüllt.", "error");
                return;
            }
            
            try {
                const userDocRef = doc(db, 'users', userId);
                await updateDoc(userDocRef, {
                    skills: arrayUnion(skillId),
                    skillPoints: increment(-skill.cost)
                });
                showNotification(`Skill "${skill.name}" erlernt!`, "success");
            } catch (error) {
                console.error("Error learning skill:", error);
                showNotification("Fehler beim Erlernen des Skills.", "error");
            }
        }
        
        async function resetSkills() {
            const userId = auth.currentUser?.uid;
            if (!userId || !currentUserProfile) return;
            
            const skillPointsToRestore = (currentUserProfile.level || 1) - 1;
            
            try {
                const userDocRef = doc(db, 'users', userId);
                await updateDoc(userDocRef, {
                    skills: [],
                    skillPoints: skillPointsToRestore
                });
                showNotification("Alle Skills zurückgesetzt.", "info");
            } catch (error) {
                 console.error("Error resetting skills:", error);
                showNotification("Fehler beim Zurücksetzen.", "error");
            }
        }

        openSkillsBtn.addEventListener('click', openSkillTree);

        document.getElementById('skill-list-panel')?.addEventListener('click', (e) => {
            const skillNode = e.target.closest('.skill-node');
            if (skillNode) {
                selectedSkillId = skillNode.dataset.skillId;
                renderSkillListPanel(); // To update selection highlight
                renderSkillDetailPanel();
            }
        });

        document.getElementById('skill-detail-panel')?.addEventListener('click', (e) => {
             const learnBtn = e.target.closest('#learn-skill-btn');
             if (learnBtn && !learnBtn.disabled) {
                 learnSkill(learnBtn.dataset.skillId);
             }
        });
        
        document.getElementById('reset-skills-btn')?.addEventListener('click', resetSkills);


        // --- Achievement Logic ---
        const achievementIconsSelection = document.getElementById('achievement-icons-selection');
        
        function renderAchievements(userProfile) {
            if (!userProfile || !achievementsList) return;
            achievementsList.innerHTML = '';
            achievementIconsSelection.innerHTML = '';
            
            const displayedAchievements = userProfile.displayedAchievements || [];

            achievementDatabase.forEach(ach => {
                const isCompleted = userProfile.achievements && userProfile.achievements[ach.id];
                const achEl = document.createElement('div');
                achEl.className = `p-3 rounded-lg flex items-start gap-4 transition-colors ${isCompleted ? 'bg-green-900 bg-opacity-40' : 'bg-gray-700'}`;
                
                achEl.innerHTML = `
                    <div class="text-2xl font-bold ${isCompleted ? 'text-green-400' : 'text-gray-500'}">${ach.icon}</div>
                    <div>
                        <h4 class="font-bold ${isCompleted ? 'text-white' : 'text-gray-400'}">${ach.name}</h4>
                        <p class="text-sm text-gray-400">${ach.description}</p>
                    </div>
                `;
                achievementsList.appendChild(achEl);

                // Render selectable icons for completed achievements
                if (isCompleted) {
                    const isSelected = displayedAchievements.includes(ach.id);
                    const iconSelectorEl = document.createElement('div');
                    iconSelectorEl.className = `achievement-icon-selector p-2 rounded-md cursor-pointer text-2xl ${isSelected ? 'selected' : ''}`;
                    iconSelectorEl.textContent = ach.icon;
                    iconSelectorEl.title = ach.name;
                    iconSelectorEl.dataset.achievementId = ach.id;
                    achievementIconsSelection.appendChild(iconSelectorEl);
                }
            });
        }
        
        achievementIconsSelection.addEventListener('click', async (e) => {
            const selector = e.target.closest('.achievement-icon-selector');
            const userId = auth.currentUser?.uid;
            if (!selector || !userId) return;

            const achId = selector.dataset.achievementId;
            const userDocRef = doc(db, 'users', userId);
            const displayed = currentUserProfile.displayedAchievements || [];

            if (displayed.includes(achId)) {
                await updateDoc(userDocRef, { displayedAchievements: arrayRemove(achId) });
            } else {
                if (displayed.length >= 10) {
                    showNotification("Maximal 10 Symbole können angezeigt werden.", "error");
                    return;
                }
                await updateDoc(userDocRef, { displayedAchievements: arrayUnion(achId) });
            }
        });


        async function checkAndGrantAchievements(userId, userProfile) {
            if (!userProfile) return;
            const userDocRef = doc(db, 'users', userId);
            const updatePayload = {};
            let hasNewAchievements = false;

            for (const achievement of achievementDatabase) {
                const isAlreadyAchieved = userProfile.achievements && userProfile.achievements[achievement.id];
                if (isAlreadyAchieved) continue;

                let conditionMet = false;
                switch (achievement.condition.type) {
                    case 'questsCompleted':
                        conditionMet = (userProfile.questsCompleted || 0) >= achievement.condition.value;
                        break;
                    case 'level':
                        conditionMet = (userProfile.level || 1) >= achievement.condition.value;
                        break;
                    case 'pomodorosCompleted':
                        conditionMet = (userProfile.pomodorosCompleted || 0) >= achievement.condition.value;
                        break;
                }

                if (conditionMet) {
                    hasNewAchievements = true;
                    showNotification(`Erfolg freigeschaltet: ${achievement.name}`);
                    updatePayload[`achievements.${achievement.id}`] = true;

                    if (achievement.reward) {
                        if (achievement.reward.type === 'xp') {
                            updatePayload.xp = increment(achievement.reward.amount);
                        } else if (achievement.reward.type === 'statPoints') {
                            updatePayload.statPoints = increment(achievement.reward.amount);
                        }
                    }
                }
            }

            if (hasNewAchievements) {
                await updateDoc(userDocRef, updatePayload);
            }
        }

        // --- Equipment & Inventory Logic ---
        const unequipAllBtn = document.getElementById('unequip-all-btn');
        unequipAllBtn.addEventListener('click', () => {
             if (auth.currentUser) {
                unequipAllItems(auth.currentUser.uid);
            }
        });

        equipmentSlotsContainer.addEventListener('click', (e) => {
            const slot = e.target.closest('.equipment-slot');
            if (slot && auth.currentUser) {
                document.querySelectorAll('#equipment-slots-container .equipment-slot.selected').forEach(el => el.classList.remove('selected'));
                slot.classList.add('selected');

                const slotType = slot.dataset.slotType;
                const item = currentUserProfile.equipment?.[slotType];
                updateItemDetails(equipmentItemDetails, item, { unequip: true });
            }
        });

        function updateItemDetails(detailsContainer, item, options = {}) {
            let contentHtml;
            if (!item || item.id === 'blocked_slot') {
                contentHtml = `<p class="text-gray-400 text-center flex-grow">Wähle ein Item aus</p>`;
            } else {
                const rarity = rarityTiers[item.rarity] || rarityTiers.common;
                const bonusesHtml = Object.entries(item.bonuses || {}).map(([stat, val]) => `<li>${stat}: +${val}</li>`).join('');
                const baseStatsHtml = Object.entries(item.baseStats || {}).map(([stat, val]) => `<li>${stat}: ${val}</li>`).join('');
                const effectHtml = item.effect ? `<li>Effekt: ${item.effect.type} (+${item.effect.amount})</li>` : '';
                
                let buttons = [];
                if (options.equip) buttons.push(`<button data-action="equip" data-item-id="${item.docId}" class="w-full text-sm bg-blue-500 hover:bg-blue-600 rounded px-2 py-1">Ausrüsten</button>`);
                if (options.use) buttons.push(`<button data-action="use" data-item-id="${item.docId}" class="w-full text-sm bg-green-500 hover:bg-green-600 rounded px-2 py-1">Benutzen</button>`);
                if (options.unequip) buttons.push(`<button data-action="unequip" data-slot-type="${item.slot}" class="w-full text-sm bg-yellow-500 hover:bg-yellow-600 rounded px-2 py-1">Ablegen</button>`);
                buttons.push(`<button data-action="trade" data-item-id="${item.docId}" class="w-full text-sm bg-gray-500 cursor-not-allowed rounded px-2 py-1" disabled>Handeln</button>`);
                
                contentHtml = `
                    <div class="flex-grow">
                        <div class="text-center"><span class="text-5xl">${item.icon}</span></div>
                        <h4 class="font-bold text-center my-2 ${rarity.color}">${item.name}</h4>
                        <p class="text-xs text-center text-gray-400 -mt-2 mb-2">${rarity.name}</p>
                        <ul class="text-xs text-gray-300 space-y-1">${baseStatsHtml}${bonusesHtml}${effectHtml}</ul>
                    </div>
                    <div class="mt-4 space-y-2">${buttons.join('')}</div>
                `;
            }
            detailsContainer.innerHTML = `${contentHtml}<div id="inventory-item-comparison" class="mt-4 border-t border-gray-700 pt-2"></div>`;
        }


        equipmentItemDetails.addEventListener('click', e => {
            const button = e.target.closest('button[data-action="unequip"]');
            if (button && auth.currentUser) {
                unequipItem(auth.currentUser.uid, button.dataset.slotType);
                updateItemDetails(equipmentItemDetails, null);
            }
        });
       
        async function unequipAllItems(userId) {
            const userRef = doc(db, 'users', userId);
            try {
                const userDoc = await getDoc(userRef);
                if (!userDoc.exists() || !userDoc.data().equipment) return;

                const equippedItems = Object.values(userDoc.data().equipment).filter(item => item.id !== 'blocked_slot');
                if (equippedItems.length === 0) {
                    return showNotification("Nichts zum Ablegen vorhanden.");
                }

                const addPromises = equippedItems.map(item => addItemToInventory(userId, item, true));
                await Promise.all(addPromises);
                
                await updateDoc(userRef, { equipment: {} });
                showNotification("Alle Items abgelegt.");

            } catch(error) {
                console.error("Unequip all failed:", error);
            }
        }


        async function equipItem(userId, itemDocId) {
            const userRef = doc(db, 'users', userId);
            const itemInventoryRef = doc(db, 'users', userId, 'inventory', itemDocId);
            
            let itemsToUnequip = [];
            let itemToEquipData = null;

            try {
                await runTransaction(db, async (transaction) => {
                    const userDoc = await transaction.get(userRef);
                    const invItemDoc = await transaction.get(itemInventoryRef);
        
                    if (!userDoc.exists()) throw "User not found.";
                    if (!invItemDoc.exists()) throw "Item to equip not found in inventory.";
                    
                    itemToEquipData = invItemDoc.data();
                    const itemToEquip = { docId: invItemDoc.id, ...itemToEquipData };
                    const slotToOccupy = itemToEquip.slot;
                    if (!slotToOccupy) throw "Item has no slot defined.";

                    const currentEquipment = userDoc.data().equipment || {};
                    const newEquipment = { ...currentEquipment };
                    
                    if (itemToEquip.hands === 2) {
                        if (currentEquipment.weapon1) itemsToUnequip.push(currentEquipment.weapon1);
                        if (currentEquipment.weapon2 && currentEquipment.weapon2.id !== 'blocked_slot') itemsToUnequip.push(currentEquipment.weapon2);
                        delete newEquipment.weapon1;
                        delete newEquipment.weapon2;
                        newEquipment.weapon1 = { ...itemToEquip, quantity: 1};
                        newEquipment.weapon2 = { id: 'blocked_slot', name: 'Blockiert', icon: '🚫', slot: 'weapon2'};
                    } else { // 1-handed item
                         if (currentEquipment[slotToOccupy]) itemsToUnequip.push(currentEquipment[slotToOccupy]);
                        newEquipment[slotToOccupy] = { ...itemToEquip, quantity: 1 };
                    }
                    
                    if (itemToEquip.quantity > 1) {
                        transaction.update(itemInventoryRef, { quantity: increment(-1) });
                    } else {
                        transaction.delete(itemInventoryRef);
                    }
                    
                    transaction.update(userRef, { equipment: newEquipment });
                });

                if (itemsToUnequip.length > 0) {
                    for (const item of itemsToUnequip) {
                       await addItemToInventory(userId, item, true);
                    }
                }

                showNotification(`${itemToEquipData.name} ausgerüstet.`);
            } catch (error) {
                console.error("Transaction failed:", error);
                showNotification(`Ausrüsten fehlgeschlagen: ${error.message || error}`);
            }
        }
        
        async function unequipItem(userId, slot) {
             const userRef = doc(db, 'users', userId);
             try {
                const userDoc = await getDoc(userRef);
                if (!userDoc.exists()) return;
                
                const equipment = userDoc.data().equipment || {};
                const itemToUnequip = equipment[slot];
                if (!itemToUnequip) return;

                const updatePayload = { [`equipment.${slot}`]: deleteField() };
                
                if (itemToUnequip.hands === 2) {
                    updatePayload['equipment.weapon2'] = deleteField();
                }

                await updateDoc(userRef, updatePayload);
                await addItemToInventory(userId, itemToUnequip, true);
                
                showNotification(`${itemToUnequip.name} abgelegt.`);
             } catch (error) { console.error("Unequip failed:", error); }
        }

        async function useItem(userId, itemDocId) {
            const userRef = doc(db, 'users', userId);
            const itemInventoryRef = doc(db, 'users', userId, 'inventory', itemDocId);
            let usedItemName = "Item";
            try {
                await runTransaction(db, async (transaction) => {
                    const userDoc = await transaction.get(userRef);
                    const itemDoc = await transaction.get(itemInventoryRef);

                    if (!userDoc.exists() || !itemDoc.exists()) throw new Error("User or Item not found");

                    const userData = userDoc.data();
                    const itemData = itemDoc.data();
                    const itemEffect = itemData.effect;
                    usedItemName = itemData.name;

                    if (!itemEffect) throw new Error("Item has no effect");

                    let updateData = {};
                    
                    const totalStats = { ...userData.stats };
                     if (userData.equipment) {
                        Object.values(userData.equipment).forEach(item => {
                            if (item && item.bonuses) {
                                Object.entries(item.bonuses).forEach(([stat, value]) => {
                                    totalStats[stat] = (totalStats[stat] || 0) + value;
                                });
                            }
                        });
                    }

                    if (itemEffect.type === 'heal') {
                        const maxHp = calculateMaxHp(totalStats.vitality);
                        const newCurrentHp = Math.min(maxHp, (userData.hp.current || 0) + itemEffect.amount);
                        updateData['hp.current'] = newCurrentHp;
                    } else if (itemEffect.type === 'mana') {
                        const maxMana = calculateMaxMana(totalStats.int);
                        const newCurrentMana = Math.min(maxMana, (userData.mana.current || 0) + itemEffect.amount);
                        updateData['mana.current'] = newCurrentMana;
                    }

                    transaction.update(userRef, updateData);

                    if (itemData.quantity > 1) {
                        transaction.update(itemInventoryRef, { quantity: increment(-1) });
                    } else {
                        transaction.delete(itemInventoryRef);
                    }
                });
                showNotification(`${usedItemName} benutzt!`);
            } catch (error) {
                console.error("Failed to use item:", error);
                showNotification(`Benutzen fehlgeschlagen: ${error.message}`);
            }
        }


        async function addItemToInventory(userId, itemToAdd, forceNewStack = false) {
             if (!userId || !itemToAdd) return;
            const inventoryRef = collection(db, 'users', userId, 'inventory');
            
            if (itemToAdd.type !== 'consumable' || forceNewStack) {
                const docRef = doc(inventoryRef);
                await setDoc(docRef, { ...itemToAdd, docId: docRef.id, quantity: 1 });
                return;
            }

            const q = query(inventoryRef, where("id", "==", itemToAdd.id));
            const querySnapshot = await getDocs(q);

            if (!querySnapshot.empty) {
                await updateDoc(querySnapshot.docs[0].ref, { quantity: increment(1) });
            } else {
                await addDoc(inventoryRef, { ...itemToAdd, quantity: 1 });
            }
        }
        
        let allInventoryItems = [];
        const listenToInventory = (userId) => {
            if (inventoryUnsubscribe) inventoryUnsubscribe();
            inventoryUnsubscribe = onSnapshot(query(collection(db, 'users', userId, 'inventory')), (snapshot) => {
                allInventoryItems = snapshot.docs.map(doc => ({ docId: doc.id, ...doc.data() }));
                
                const hpPotions = allInventoryItems.find(item => item.id === 'potion_hp_small');
                const manaPotions = allInventoryItems.find(item => item.id === 'potion_mana_small');
                const hpPotionCount = hpPotions ? hpPotions.quantity : 0;
                const manaPotionCount = manaPotions ? manaPotions.quantity : 0;
                document.getElementById('hp-potion-count').textContent = hpPotionCount;
                document.getElementById('mana-potion-count').textContent = manaPotionCount;

                renderInventoryPage();
            });
        };
        
        function renderInventoryPage() {
            let filteredItems;
            if (inventorySortCategory === 'all') {
                filteredItems = allInventoryItems;
            } else if (inventorySortCategory === 'accessory') {
                const accessorySlots = ['amulet', 'ring1', 'ring2'];
                filteredItems = allInventoryItems.filter(item => item.type === 'armor' && accessorySlots.includes(item.slot));
            } else {
                filteredItems = allInventoryItems.filter(item => item.type === inventorySortCategory);
            }
                
            const totalPages = Math.max(1, Math.ceil(filteredItems.length / inventoryItemsPerPage));
            inventoryCurrentPage = Math.min(inventoryCurrentPage, totalPages);

            const startIndex = (inventoryCurrentPage - 1) * inventoryItemsPerPage;
            const endIndex = startIndex + inventoryItemsPerPage;
            const itemsToShow = filteredItems.slice(startIndex, endIndex);

            const inventoryList = document.getElementById('inventory-list-container');
            inventoryList.innerHTML = '';
            if (itemsToShow.length === 0) {
                inventoryList.innerHTML = `<p class="text-gray-400 text-sm text-center">Keine Items in dieser Kategorie.</p>`;
            } else {
                 itemsToShow.forEach(item => {
                    const itemEl = document.createElement('div');
                    itemEl.className = 'group flex justify-between items-center p-2 bg-gray-700 rounded hover:bg-gray-600 cursor-pointer';
                    itemEl.dataset.itemId = item.docId;
                    
                    let buttonsHtml = `<div class="flex-shrink-0 flex gap-1">`;
                    if (item.type === 'weapon' || item.type === 'armor' || item.type === 'tool') {
                         buttonsHtml += `<button data-action="equip" data-item-id="${item.docId}" class="text-xs bg-blue-600 hover:bg-blue-500 p-1 rounded">Ausrüsten</button>`;
                    }
                    if (item.type === 'consumable') {
                        buttonsHtml += `<button data-action="use" data-item-id="${item.docId}" class="text-xs bg-green-600 hover:bg-green-500 p-1 rounded">Benutzen</button>`;
                    }
                    buttonsHtml += `<button data-action="delete" data-item-id="${item.docId}" title="Verwerfen" class="text-xs bg-red-600 hover:bg-red-500 px-2 py-1 rounded">🗑️</button>`;
                    buttonsHtml += `</div>`;

                    const rarityColor = rarityTiers[item.rarity]?.color || 'text-gray-300';
                    itemEl.innerHTML = `
                        <div class="flex-grow flex items-center gap-2">
                            <span class="font-bold text-lg">${item.icon}</span>
                            <div>
                                <span class="font-bold ${rarityColor}">${item.name}</span> 
                                <span class="text-gray-400">${item.quantity > 1 ? `(x${item.quantity})` : ''}</span>
                            </div>
                        </div>
                        ${buttonsHtml}
                    `;
                    inventoryList.appendChild(itemEl);
                });
            }

            inventoryPageInfo.textContent = `Seite ${inventoryCurrentPage} / ${totalPages}`;
            inventoryPagePrev.disabled = inventoryCurrentPage === 1;
            inventoryPageNext.disabled = inventoryCurrentPage >= totalPages;
        }

        document.getElementById('inventory-sort-buttons').addEventListener('click', e => {
            const button = e.target.closest('button');
            if(button) {
                inventorySortCategory = button.dataset.sortCategory;
                inventoryCurrentPage = 1;
                document.querySelectorAll('#inventory-sort-buttons button').forEach(btn => btn.classList.replace('bg-indigo-600', 'bg-gray-600'));
                button.classList.replace('bg-gray-600', 'bg-indigo-600');
                renderInventoryPage();
                updateItemDetails(inventoryItemDetails, null);
            }
        });
        
        inventoryPagePrev.addEventListener('click', () => {
            if(inventoryCurrentPage > 1) {
                inventoryCurrentPage--;
                renderInventoryPage();
            }
        });

        inventoryPageNext.addEventListener('click', () => {
             const totalItems = allInventoryItems.filter(item => inventorySortCategory === 'all' || item.type === inventorySortCategory).length;
             const totalPages = Math.ceil(totalItems / inventoryItemsPerPage);
             if(inventoryCurrentPage < totalPages) {
                inventoryCurrentPage++;
                renderInventoryPage();
            }
        });


        inventoryListContainer.addEventListener('click', async (event) => {
            const userId = auth.currentUser?.uid;
            if (!userId) return;

            const equipBtn = event.target.closest('button[data-action="equip"]');
            if (equipBtn) {
                equipItem(userId, equipBtn.dataset.itemId);
                return;
            }

            const useBtn = event.target.closest('button[data-action="use"]');
            if (useBtn) {
                useItem(userId, useBtn.dataset.itemId);
                return;
            }

            const deleteBtn = event.target.closest('button[data-action="delete"]');
            if (deleteBtn) {
                event.stopPropagation();
                itemToDeleteId = deleteBtn.dataset.itemId;
                petToReleaseId = null; // Ensure we're not deleting a pet
                const itemToDelete = allInventoryItems.find(i => i.docId === itemToDeleteId);
                deleteConfirmText.textContent = `Willst du "${itemToDelete?.name || 'diesen Gegenstand'}" wirklich verwerfen?`;
                deleteConfirmModal.classList.remove('hidden');
                return;
            }
            
            const itemEl = event.target.closest('.group[data-item-id]');
            if (itemEl) {
                document.querySelectorAll('#inventory-list-container .group.selected').forEach(el => el.classList.remove('selected'));
                itemEl.classList.add('selected');

                const itemId = itemEl.dataset.itemId;
                const item = allInventoryItems.find(i => i.docId === itemId);
                if(item) {
                    const options = { 
                        equip: item.type === 'weapon' || item.type === 'armor' || item.type === 'tool',
                        use: item.type === 'consumable' 
                    };
                    updateItemDetails(inventoryItemDetails, item, options);
                    renderComparisonInDetails(item);
                }
            }
        });
        
        inventoryItemDetails.addEventListener('click', e => {
            const button = e.target.closest('button[data-item-id]');
             if (button && auth.currentUser) {
                const { action, itemId } = button.dataset;
                if (action === 'delete') { // Though this button is removed from details pane, keeping for safety
                    if (confirm('Gegenstand wirklich verwerfen?')) {
                        deleteDoc(doc(db, 'users', auth.currentUser.uid, 'inventory', itemId))
                    }
                };
                if (action === 'equip') equipItem(auth.currentUser.uid, itemId);
                if (action === 'use') useItem(auth.currentUser.uid, itemId);
                updateItemDetails(inventoryItemDetails, null);
            }
        });
        
        function getDeltaSpan(delta) {
            if (delta > 0) return `<span class="text-green-400">(+${delta})</span>`;
            if (delta < 0) return `<span class="text-red-400">(${delta})</span>`;
            return '';
        }

        function generateComparisonTable(newItem, equippedItem, title) {
            let html = `<div class="flex-1"><h5 class="text-sm font-bold text-center text-gray-400 mb-1">${title}</h5><table class="w-full text-xs">`;
            const allStats = new Set([...Object.keys(newItem?.bonuses || {}), ...Object.keys(equippedItem?.bonuses || {})]);

            if (allStats.size === 0) return '<tbody><tr><td class="text-gray-500">Keine Boni</td></tr></tbody></table></div>';

            html += '<tbody>';
            for (const stat of allStats) {
                const newVal = newItem?.bonuses?.[stat] || 0;
                const oldVal = equippedItem?.bonuses?.[stat] || 0;
                const delta = newVal - oldVal;
                html += `<tr><td class="pr-2 capitalize">${stat}</td><td class="font-bold text-right">${newVal} ${getDeltaSpan(delta)}</td></tr>`;
            }
            html += '</tbody></table></div>';
            return html;
        }

        function renderComparisonInDetails(inventoryItem) {
            const comparisonContainer = document.getElementById('inventory-item-comparison');
            if (!comparisonContainer) return;
            comparisonContainer.innerHTML = '';
            
            if (inventoryItem.type !== 'weapon') return;

            const equipment = currentUserProfile.equipment || {};
            const equippedMain = equipment.weapon1;
            const equippedOff = equipment.weapon2;

            if (inventoryItem.hands === 2) {
                // Compare 2H from inventory vs. currently equipped total
                const combinedEquipped = { name: 'Ausrüstung', bonuses: {} };
                // Sum up bonuses from main hand and off-hand (if not blocked)
                [equippedMain, equippedOff].forEach(item => {
                    if (item && item.id !== 'blocked_slot' && item.bonuses) {
                        Object.entries(item.bonuses).forEach(([stat, val]) => {
                            combinedEquipped.bonuses[stat] = (combinedEquipped.bonuses[stat] || 0) + val;
                        });
                    }
                });
                comparisonContainer.innerHTML = generateComparisonTable(inventoryItem, combinedEquipped, 'Vergleich mit Ausrüstung');
            } else {
                // Compare 1H from inventory vs. main and off-hand separately
                const mainHandComparison = generateComparisonTable(inventoryItem, equippedMain, 'Ersetzt Main-Hand');
                const offHandComparison = generateComparisonTable(inventoryItem, (equippedOff?.id !== 'blocked_slot' ? equippedOff : null), 'Ersetzt Off-Hand');
                comparisonContainer.innerHTML = `<div class="flex gap-2">${mainHandComparison}${offHandComparison}</div>`;
            }
        }
        
        // --- Delete Confirmation Logic ---
        deleteCancelBtn.addEventListener('click', () => {
            itemToDeleteId = null;
            petToReleaseId = null;
            deleteConfirmModal.classList.add('hidden');
        });

        deleteConfirmBtn.addEventListener('click', async () => {
            if (itemToDeleteId) {
                await deleteInventoryItem();
            } else if (petToReleaseId) {
                await releasePet();
            }
        });
        
        async function deleteInventoryItem() {
            const userId = auth.currentUser?.uid;
            if (!itemToDeleteId || !userId) return;

            try {
                const itemToDelete = allInventoryItems.find(i => i.docId === itemToDeleteId);
                await deleteDoc(doc(db, 'users', userId, 'inventory', itemToDeleteId));
                showNotification(`"${itemToDelete?.name || 'Gegenstand'}" verworfen.`);

                const detailsPaneItemId = inventoryItemDetails.querySelector('button[data-item-id]')?.dataset.itemId;
                if (detailsPaneItemId === itemToDeleteId) {
                    updateItemDetails(inventoryItemDetails, null);
                }
            } catch (error) {
                console.error("Error deleting item:", error);
                showNotification("Fehler beim Verwerfen des Gegenstands.");
            } finally {
                itemToDeleteId = null;
                deleteConfirmModal.classList.add('hidden');
            }
        }

        // Item Found Modal Logic
        const itemFoundModal = document.getElementById('item-found-modal');
        const modalItemIcon = document.getElementById('modal-item-icon');
        const modalItemName = document.getElementById('modal-item-name');
        const modalKeepBtn = document.getElementById('modal-keep-btn');
        const modalDiscardBtn = document.getElementById('modal-discard-btn');
        
        const showItemFoundPopup = (item) => {
            currentItemFound = { ...item };
            const rarity = rarityTiers[item.rarity] || rarityTiers.common;
            modalItemIcon.textContent = currentItemFound.icon;
            modalItemName.innerHTML = `<span class="${rarity.color}">${currentItemFound.name}</span><p class="text-sm text-gray-400 mt-1">${rarity.name}</p>`;
            itemFoundModal.classList.remove('hidden');
        };
        const hideItemFoundPopup = () => {
            itemFoundModal.classList.add('hidden');
            currentItemFound = null;
        };
        modalKeepBtn.addEventListener('click', () => {
            if (currentItemFound && auth.currentUser) addItemToInventory(auth.currentUser.uid, currentItemFound);
            hideItemFoundPopup();
        });
        modalDiscardBtn.addEventListener('click', () => {
            if(currentItemFound) showNotification(`${currentItemFound.name} verworfen.`);
            hideItemFoundPopup();
        });

        const listenToJournal = (userId) => {
            if (journalUnsubscribe) journalUnsubscribe();
            const journalRef = collection(db, 'users', userId, 'journal');
            journalUnsubscribe = onSnapshot(query(journalRef), (snapshot) => {
                journalList.innerHTML = '';
                if (snapshot.empty) {
                    journalList.innerHTML = '<p class="text-gray-400 text-sm">Noch keine Quests erledigt.</p>';
                    return;
                }
                const quests = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                quests.sort((a,b) => (b.completedAt?.toMillis() || 0) - (a.completedAt?.toMillis() || 0));

                quests.forEach(quest => {
                    const questEl = document.createElement('div');
                    questEl.className = 'p-2 bg-gray-700 rounded-lg text-sm text-gray-400';
                    questEl.textContent = quest.text;
                    journalList.appendChild(questEl);
                });
            });
        };

        const fetchTodos = (userId) => {
             if (todosUnsubscribe) todosUnsubscribe();
            const q = query(collection(db, 'todos'), where("userId", "==", userId));
            todosUnsubscribe = onSnapshot(q, async (snapshot) => {
                localQuests = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                await checkAndResetDailies(userId);
                renderTodos();
                renderFocusQuest();
                populateGanttProjectFilter();
                renderGanttChart();
                checkGanttAutoFocus();
            });
        };
        
        function getXpForPriority(priority) {
            const xpMap = { 'Leicht': 10, 'Mittel': 25, 'Schwer': 50 };
            return xpMap[priority] || 0;
        }
        
        function getCurrencyForPriority(priority) {
            const rewards = { 'Leicht': 5, 'Mittel': 15, 'Schwer': 30 }; // Currency-Quest-Reward
            let bronze = rewards[priority] || 0;
            
            const gold = Math.floor(bronze / 10000);
            let remaining = bronze % 10000;
            const silver = Math.floor(remaining / 100);
            const finalBronze = remaining % 100;

            let html = '';
            if (gold > 0) html += `<span class="flex items-center gap-1" title="${gold} Gold">💰<span class="text-yellow-400">${gold}</span></span>`;
            if (silver > 0) html += `<span class="flex items-center gap-1" title="${silver} Silber">🪙<span class="text-gray-300">${silver}</span></span>`;
            if (finalBronze > 0 || (gold === 0 && silver === 0)) html += `<span class="flex items-center gap-1" title="${finalBronze} Bronze">🥉<span class="text-orange-400">${finalBronze}</span></span>`;

            return html;
        }

        async function handleXpGain(userId, xpGained) {
            const userRef = doc(db, "users", userId);
            try {
                await updateDoc(userRef, { xp: increment(xpGained) });
                const userDoc = await getDoc(userRef);
                const userData = userDoc.data();
                
                let currentLevel = userData.level;
                let currentXp = userData.xp;
                const getXpForLevel = (level) => (level - 1) * 100;
                
                let hasLeveledUp = false;
                let levelsGained = 0;
                while (currentXp >= getXpForLevel(currentLevel + 1)) {
                    currentLevel++;
                    levelsGained++;
                    hasLeveledUp = true;
                }

                if (hasLeveledUp) {
                    const newLevel = currentLevel;
                    const statPointsGained = levelsGained * 5;
                    const skillPointsGained = levelsGained;

                    await updateDoc(userRef, {
                        level: newLevel,
                        statPoints: increment(statPointsGained),
                        skillPoints: increment(skillPointsGained)
                    });
                    showNotification(`Level Up! Du bist jetzt Level ${newLevel}!`, 'success', 5000);
                }
                 // Always check achievements after XP gain, even if no level up, in case of a direct XP achievement.
                const updatedUserDoc = await getDoc(userRef);
                await checkAndGrantAchievements(userId, updatedUserDoc.data());
            } catch (error) {
                console.error("Error handling XP gain:", error);
            }
        }

        let currentQuestSort = { field: 'priority', direction: 'asc' };
        let currentQuestFilter = 'all';

        const questListFilters = document.getElementById('quest-list-filters');
        
        questListFilters.addEventListener('change', e => {
            if (e.target.id === 'quest-sort-select') {
                currentQuestSort.field = e.target.value;
                renderTodos();
            }
        });

        questListFilters.addEventListener('click', e => {
            const filterBtn = e.target.closest('.quest-filter-btn');
            if (filterBtn) {
                currentQuestFilter = filterBtn.dataset.filter;
                document.querySelectorAll('.quest-filter-btn').forEach(btn => btn.classList.remove('active', 'bg-indigo-600'));
                filterBtn.classList.add('active', 'bg-indigo-600');
                renderTodos();
            }
        });


        const applyQuestFiltersAndSort = (quests) => {
            let filteredQuests = [...quests];

            // Apply deadline filter first
            const now = new Date();
            const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const todayEnd = new Date(todayStart.getTime() + 24 * 60 * 60 * 1000 - 1);
            
            if (currentQuestFilter === 'dueToday') {
                filteredQuests = filteredQuests.filter(q => {
                    if (!q.deadline) return false;
                    const deadlineDate = q.deadline.toDate();
                    return deadlineDate >= todayStart && deadlineDate <= todayEnd;
                });
            } else if (currentQuestFilter === 'dueThisWeek') {
                const weekStart = new Date(todayStart);
                // Set to beginning of the week (Monday)
                weekStart.setDate(weekStart.getDate() - (weekStart.getDay() + 6) % 7);
                const weekEnd = new Date(weekStart.getTime() + 7 * 24 * 60 * 60 * 1000 - 1);
                
                filteredQuests = filteredQuests.filter(q => {
                    if (!q.deadline) return false;
                    const deadlineDate = q.deadline.toDate();
                    return deadlineDate >= weekStart && deadlineDate <= weekEnd;
                });
            }
            
            // Apply sorting
            filteredQuests.sort((a, b) => {
                const field = currentQuestSort.field;
                let valA, valB;

                if (field === 'priority') {
                    const priorityOrder = { 'Schwer': 0, 'Mittel': 1, 'Leicht': 2 };
                    valA = priorityOrder[a.priority];
                    valB = priorityOrder[b.priority];
                } else if (field === 'xp') {
                    valA = getXpForPriority(b.priority); // Higher XP first
                    valB = getXpForPriority(a.priority);
                } else if (field === 'createdAt') {
                    valA = b.createdAt?.toMillis() || 0; // Newest first
                    valB = a.createdAt?.toMillis() || 0;
                } else { // 'text'
                    valA = a.text.toLowerCase();
                    valB = b.text.toLowerCase();
                }

                if (valA < valB) return -1;
                if (valA > valB) return 1;
                return 0;
            });

            return filteredQuests;
        };

        const updateMyQuestsButtonCounts = () => {
            const countsContainer = document.getElementById('my-quests-counts');
            if (!countsContainer) return;

            const counts = localQuests.filter(q => !q.isDaily).reduce((acc, quest) => {
                acc[quest.priority] = (acc[quest.priority] || 0) + 1;
                return acc;
            }, {});

            countsContainer.innerHTML = `
                <span class="flex items-center gap-1" title="Leichte Quests">
                    <span class="w-2 h-2 rounded-full bg-green-500"></span>
                    ${counts['Leicht'] || 0}
                </span>
                <span class="flex items-center gap-1" title="Mittel-schwere Quests">
                    <span class="w-2 h-2 rounded-full bg-yellow-500"></span>
                     ${counts['Mittel'] || 0}
                </span>
                <span class="flex items-center gap-1" title="Schwere Quests">
                    <span class="w-2 h-2 rounded-full bg-red-500"></span>
                     ${counts['Schwer'] || 0}
                </span>
            `;
        }

        const isDateToday = (date) => {
            if (!date) return false;
            const today = new Date();
            return date.getDate() === today.getDate() &&
                   date.getMonth() === today.getMonth() &&
                   date.getFullYear() === today.getFullYear();
        };

        const renderTodos = () => {
            todoListContainer.innerHTML = '';
            
            const activeQuests = localQuests.filter(q => {
                if (q.isDaily) {
                    return !isDateToday(q.lastCompleted?.toDate());
                }
                return true;
            });

            const filteredAndSortedQuests = applyQuestFiltersAndSort(activeQuests);

            if (filteredAndSortedQuests.length === 0) {
                 todoListContainer.innerHTML = '<p class="text-gray-400 text-center">Keine Quests entsprechen den aktuellen Filtern.</p>';
                 return;
            }
            
            const questsToRender = filteredAndSortedQuests.filter(q => q.id !== focusedQuestId);

            questsToRender.forEach(todo => {
                const todoEl = document.createElement('div');
                todoEl.className = 'grid grid-cols-[1fr_auto_1fr] items-center gap-2 p-3 bg-gray-700 rounded-lg transition-all duration-300 hover:bg-gray-600';
                todoEl.dataset.questId = todo.id;
                
                let tagsHtml = (todo.tags || []).map(tag => `<span class="text-xs bg-gray-600 px-2 py-0.5 rounded-full">${tag}</span>`).join(' ');
                const currencyRewardHtml = getCurrencyForPriority(todo.priority);

                let durationHtml;
                if (todo.durationMinutes > 0) {
                    durationHtml = `<span class="text-sm text-gray-400">🕒 ${todo.durationMinutes} Min</span>`;
                } else {
                    durationHtml = `<input type="number" min="10" step="5" class="set-duration-input bg-gray-800 text-white rounded px-2 py-1 w-24 text-xs" data-id="${todo.id}" placeholder="Dauer setzen...">`;
                }
                
                const planButtonHtml = !todo.ganttScheduledAt 
                    ? `<button data-id="${todo.id}" class="plan-today-btn text-xs bg-blue-600 hover:bg-blue-500 p-1 rounded">Planen</button>`
                    : '';

                todoEl.innerHTML = `
                     <div class="flex-grow">
                        <p class="font-bold">${todo.text}</p>
                        <div class="flex items-center gap-2 text-xs text-gray-400 mt-1">
                            <span class="font-bold text-yellow-400">${getXpForPriority(todo.priority)} XP</span>
                            <span class="text-gray-600">|</span>
                            ${currencyRewardHtml}
                            <span class="text-gray-600">|</span>
                            ${tagsHtml}
                            ${todo.isDaily ? '<span>&#x21BA;</span>' : ''}
                        </div>
                    </div>
                    <div class="flex-shrink-0 flex flex-col gap-1">
                        <button data-id="${todo.id}" class="focus-btn text-xs bg-cyan-600 hover:bg-cyan-500 p-2 rounded-lg font-bold w-24">Fokus</button>
                    </div>
                    <div class="flex items-center justify-end gap-2">
                         ${durationHtml}
                         ${planButtonHtml}
                         <button data-id="${todo.id}" class="complete-btn flex-shrink-0 w-6 h-6 border-2 border-gray-500 rounded-full transition-colors duration-300 hover:bg-green-500"></button>
                         <button data-id="${todo.id}" class="delete-btn text-gray-400 hover:text-red-500 font-bold text-xl">&times;</button>
                    </div>
                `;
                todoListContainer.appendChild(todoEl);
            });
            updateMyQuestsButtonCounts();
        };
        
        const renderFocusQuest = () => {
            focusQuestContainer.innerHTML = '';
            const mainContentEl = document.getElementById('main-content');
            
            const renderSuggestion = () => {
                 const priorityOrder = { 'Schwer': 0, 'Mittel': 1, 'Leicht': 2 };
                const suggestions = [...localQuests]
                    .filter(q => q.durationMinutes > 0 && (!q.isDaily || !isDateToday(q.lastCompleted?.toDate())))
                    .sort((a, b) => {
                        const durationDiff = (a.durationMinutes || 9999) - (b.durationMinutes || 9999);
                        if (durationDiff !== 0) return durationDiff;
                        return priorityOrder[a.priority] - priorityOrder[b.priority];
                    });

                if (suggestions.length > 0) {
                    const quest = suggestions[0];
                    focusQuestContainer.innerHTML = `
                        <h3 class="text-lg font-bold text-gray-400 mb-2 border-b border-gray-600 pb-2">Fokus Vorschlag</h3>
                        <div class="p-3 bg-gray-700 rounded-lg">
                            <p class="font-bold text-lg">${quest.text}</p>
                            <p class="text-sm text-gray-400">${quest.priority} | ${quest.durationMinutes} Min | ${getXpForPriority(quest.priority)} XP</p>
                            <button data-id="${quest.id}" class="accept-focus-btn mt-3 w-full bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-2 px-4 rounded-lg transition duration-300">Fokus starten</button>
                        </div>
                    `;
                } else {
                    focusQuestContainer.innerHTML = '<p class="text-center text-gray-500 text-sm">Keine Quest im Fokus. Erstelle eine neue Quest mit Zeitangabe für einen Vorschlag.</p>';
                }
            };

            if (!focusedQuestId) {
                renderSuggestion();
                mainContentEl.classList.add('blinking-border');
                continueQuestBtn.disabled = true;
                return;
            }
            mainContentEl.classList.remove('blinking-border');
            continueQuestBtn.disabled = breakTimer.timeLeft > 0;

            const quest = localQuests.find(q => q.id === focusedQuestId);
            if (!quest) {
                focusedQuestId = null;
                renderSuggestion();
                mainContentEl.classList.add('blinking-border');
                return;
            }
            
            const priorityColors = { 'Leicht': 'text-green-500', 'Mittel': 'text-yellow-500', 'Schwer': 'text-red-500' };
            const priorityBorderColors = { 'Leicht': 'border-green-500', 'Mittel': 'border-yellow-500', 'Schwer': 'border-red-500' };
            const priorityColor = priorityColors[quest.priority] || 'text-gray-400';
            const priorityBorder = priorityBorderColors[quest.priority] || 'border-gray-500';
            const currencyRewardHtml = getCurrencyForPriority(quest.priority);

            const isTimerActive = breakTimer.timeLeft > 0;

            focusQuestContainer.innerHTML = `
                <h3 class="text-lg font-bold text-cyan-400 mb-2 border-b border-gray-600 pb-2 text-center">Fokus</h3>
                <div class="relative p-3 bg-gray-900 rounded-lg border-2 border-cyan-500 flex flex-col items-center gap-4">
                    <!-- Quest Info at the top -->
                    <div>
                        <p class="font-bold text-xl text-center">${quest.text}</p>
                         <div class="flex items-center justify-center gap-2 text-sm text-gray-400 mt-1">
                            <span class="font-bold ${priorityColor}">${quest.priority}</span>
                             <span class="text-gray-600">|</span>
                             <span class="font-bold text-yellow-400">${getXpForPriority(quest.priority)} XP</span>
                             <span class="text-gray-600">|</span>
                             ${currencyRewardHtml}
                             <span class="text-gray-600">|</span>
                             <span>🕒 ${quest.durationMinutes} Min</span>
                        </div>
                    </div>
                    
                    <!-- Timer Visualizer in the center -->
                    <div class="relative w-32 h-32 bg-gray-800 border-2 border-gray-600 rounded-lg overflow-hidden flex items-center justify-center">
                        <div id="focus-timer-visual-fill" class="absolute bottom-0 left-0 w-full bg-emerald-500" style="height: 0%;"></div>
                         <div id="focus-timer-text-display" class="relative text-white text-3xl font-mono text-shadow">
                            ${formatTime(focusTimer.timeLeft)}
                        </div>
                    </div>

                    <!-- Timer Controls at the bottom -->
                    <div class="flex justify-center gap-4">
                        <button id="focus-timer-start-btn" class="px-4 py-2 bg-indigo-600 hover:bg-indigo-500 rounded font-bold" ${isTimerActive ? 'disabled' : ''}>Start</button>
                        <button id="focus-timer-pause-btn" class="px-4 py-2 bg-yellow-600 hover:bg-yellow-500 rounded font-bold" ${isTimerActive ? 'disabled' : ''}>Pause</button>
                    </div>

                    <!-- Action buttons -->
                     <button data-id="${quest.id}" class="stop-focus-btn absolute top-2 right-2 text-xs bg-gray-500 hover:bg-gray-400 p-1 rounded z-10">Fokus beenden</button>
                     <button data-id="${quest.id}" class="complete-btn absolute bottom-2 right-2 flex-shrink-0 w-8 h-8 border-2 ${priorityBorder} rounded-full transition-colors duration-300 hover:bg-green-500 z-10"></button>
                </div>
            `;
             updateFocusTimerDisplay();
        };
        
        // --- Focus & Break Timer Logic ---
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        
        function resetFocusTimer() {
            if (focusTimer.interval) clearInterval(focusTimer.interval);
            focusTimer = { interval: null, timeLeft: 0, totalWorkTimeForQuest: 0, isPaused: true, isRunning: false, questId: null };
        }
        
        function updateFocusTimerDisplay() {
            const timerText = document.getElementById('focus-timer-text-display');
            const timerFill = document.getElementById('focus-timer-visual-fill');
            if (timerText) timerText.textContent = formatTime(focusTimer.timeLeft);
            if (timerFill && focusTimer.totalWorkTimeForQuest > 0) {
                 const percentage = ((focusTimer.totalWorkTimeForQuest - focusTimer.timeLeft) / focusTimer.totalWorkTimeForQuest) * 100;
                 timerFill.style.height = `${percentage}%`;
            } else if (timerFill) {
                timerFill.style.height = '0%';
            }
        }

        function startFocusSession(quest) {
            if (!quest) return;

            focusedQuestId = quest.id;
            focusTimer.questId = quest.id;

            const workDurationMinutes = Math.min(quest.durationMinutes, 45);
            focusTimer.totalWorkTimeForQuest = workDurationMinutes * 60;
            focusTimer.timeLeft = focusTimer.totalWorkTimeForQuest;
            
            renderTodos();
            renderFocusQuest();
            startFocusTimer();
        }

        function startFocusTimer() {
            if (focusTimer.isRunning || focusTimer.timeLeft <= 0) return;
            
            focusTimer.isRunning = true;
            focusTimer.isPaused = false;
            
            focusTimer.interval = setInterval(() => {
                focusTimer.timeLeft--;
                updateFocusTimerDisplay();
                
                if (focusTimer.timeLeft < 0) {
                    pauseFocusTimer();
                    showNotification("Arbeitszeit ist um! Zeit für eine Pause.", "success");
                    startBreak();
                }
            }, 1000);
        }

        function pauseFocusTimer() {
            if (focusTimer.interval) {
                clearInterval(focusTimer.interval);
                focusTimer.isRunning = false;
                focusTimer.isPaused = true;
            }
        }
        
        function startBreak() {
            const quest = localQuests.find(q => q.id === focusedQuestId);
            let breakMinutes = 5;

            if (quest && quest.ganttScheduledAt) {
                const questEndTime = quest.ganttScheduledAt.toMillis() + quest.durationMinutes * 60000;
                const allScheduledItems = [...localQuests.filter(q => q.ganttScheduledAt), ...ganttBreaks]
                    .sort((a,b) => a.ganttScheduledAt.toMillis() - b.ganttScheduledAt.toMillis());
                
                const questIndex = allScheduledItems.findIndex(item => item.id === quest.id);
                if (questIndex > -1 && questIndex + 1 < allScheduledItems.length) {
                    const nextItem = allScheduledItems[questIndex + 1];
                    if (nextItem.type === 'break' && nextItem.ganttScheduledAt.toMillis() === questEndTime) {
                        breakMinutes = nextItem.durationMinutes;
                    }
                }
            }
            
            breakTimer.timeLeft = breakMinutes * 60;
            breakTimer.isPaused = false;
            
            updateBreakTimerDisplay();
            breakPopupModal.classList.remove('hidden');
            renderFocusQuest(); // Re-render to disable buttons

            breakTimer.interval = setInterval(() => {
                breakTimer.timeLeft--;
                updateBreakTimerDisplay();

                if (breakTimer.timeLeft < 0) {
                    clearInterval(breakTimer.interval);
                    breakTimer.isPaused = true;
                    minimizedBreakTimer.classList.add('hidden');
                    breakPopupModal.classList.add('hidden');
                    postBreakModal.classList.remove('hidden');
                }
            }, 1000);
        }

        function updateBreakTimerDisplay() {
            const formattedTime = formatTime(breakTimer.timeLeft);
            breakTimerDisplay.textContent = formattedTime;
            minimizedBreakTimerDisplay.textContent = formattedTime;
        }

        extendBreak5Btn.addEventListener('click', () => breakTimer.timeLeft += 5 * 60);
        extendBreak25Btn.addEventListener('click', () => breakTimer.timeLeft += 25 * 60);
        closeBreakPopupBtn.addEventListener('click', () => {
            breakPopupModal.classList.add('hidden');
            minimizedBreakTimer.classList.remove('hidden');
        });

        continueQuestBtn.addEventListener('click', () => {
            postBreakModal.classList.add('hidden');
            const quest = localQuests.find(q => q.id === focusedQuestId);
            startFocusSession(quest);
        });

        const setupNewQuestForm = () => {
             availableTags.forEach((tag, index) => {
                const label = document.createElement('label');
                label.className = 'flex items-center gap-2 cursor-pointer';
                const radio = document.createElement('input');
                radio.type = 'radio';
                radio.name = 'quest-tag';
                radio.value = tag;
                radio.className = 'form-radio bg-gray-700 border-gray-600 text-indigo-500 focus:ring-indigo-500';
                if (index === 0) radio.checked = true;
                label.appendChild(radio);
                label.append(tag);
                todoTagsContainer.appendChild(label);
            });
            weekDays.forEach(day => {
                const label = document.createElement('label');
                label.className = 'flex items-center gap-1 cursor-pointer';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = day;
                checkbox.className = 'form-checkbox bg-gray-700 border-gray-600 text-indigo-500 focus:ring-indigo-500';
                label.appendChild(checkbox);
                label.append(day);
                todoRepeatDaysContainer.appendChild(label);
            });
        };
        
        setupNewQuestForm();

        // New Quest Wizard Logic
        const questWizardSteps = document.querySelectorAll('.quest-wizard-step');
        const questWizardProgress = document.getElementById('quest-wizard-progress');
        const questBackBtn = document.getElementById('quest-back-btn');
        const questNextBtn = document.getElementById('quest-next-btn');
        const questSubmitBtn = document.getElementById('quest-submit-btn');
        let currentQuestStep = 1;
        const totalQuestSteps = questWizardSteps.length;
        let newQuestDuration = 0;

        function renderQuestWizardProgress() {
            questWizardProgress.innerHTML = '';
            for (let i = 1; i <= totalQuestSteps; i++) {
                const dot = document.createElement('div');
                dot.className = 'wizard-progress-dot';
                if (i <= currentQuestStep) {
                    dot.classList.add('active');
                }
                questWizardProgress.appendChild(dot);
            }
        }

        function parseDuration(inputStr) {
            let totalMinutes = 0;
            const hourMatch = inputStr.match(/(\d+)\s*h/);
            const minuteMatch = inputStr.match(/(\d+)\s*m/);
            const numberOnlyMatch = inputStr.match(/^\d+$/);

            if (hourMatch) totalMinutes += parseInt(hourMatch[1], 10) * 60;
            if (minuteMatch) totalMinutes += parseInt(minuteMatch[1], 10);
            
            if (!hourMatch && !minuteMatch && numberOnlyMatch) {
                totalMinutes = parseInt(numberOnlyMatch[1], 10);
            }
            
            return totalMinutes;
        }


        function validateCurrentQuestStep() {
            let isValid = false;
            const isDaily = todoRepeatCheckbox.checked;
            const taskType = todoTaskTypeInput.value;
            
            switch(currentQuestStep) {
                case 1: // Type
                    isValid = true;
                    break;
                case 2: // Title & Description
                    isValid = todoInput.value.trim() !== '';
                    break;
                case 3: // Duration
                     if (taskType === 'Projekt') {
                        isValid = document.getElementById('project-duration-days').value > 0;
                    } else {
                        const isFreeMode = !document.getElementById('Bearbeitungsdauer-Frei').classList.contains('hidden');
                        if (isFreeMode) {
                            isValid = parseDuration(document.getElementById('quest-duration-free-input').value) > 0;
                        } else {
                            isValid = newQuestDuration > 0;
                        }
                    }
                    break;
                case 4: // Deadline & Repeat
                    if (taskType === 'Projekt') isValid = document.getElementById('project-start-date').value !== '';
                    else isValid = isDaily ? todoStartTimeInput.value !== '' : todoDeadlineInput.value !== '';
                    break;
                case 5: // Priority & Tags
                    isValid = !!todoTagsContainer.querySelector('input:checked');
                    break;
                default:
                    isValid = false;
            }
            questNextBtn.disabled = !isValid;
        }

        function showQuestStep(step) {
            questWizardSteps.forEach(s => s.classList.add('hidden'));
            document.getElementById(`quest-step-${step}`).classList.remove('hidden');
            
            questBackBtn.classList.toggle('hidden', step === 1);
            questNextBtn.classList.toggle('hidden', step === totalQuestSteps);
            questSubmitBtn.classList.toggle('hidden', step !== totalQuestSteps);

            renderQuestWizardProgress();
            validateCurrentQuestStep();
        }
        
        function formatDuration(totalMinutes) {
            if (totalMinutes === 0) return '0m';
            const hours = Math.floor(totalMinutes / 60);
            const minutes = totalMinutes % 60;
            let result = '';
            if (hours > 0) result += `${hours}h `;
            if (minutes > 0) result += `${minutes}m`;
            return result.trim();
        }

        function resetQuestWizard() {
            addTodoForm.reset();
            currentQuestStep = 1;
            newQuestDuration = 0;
            document.getElementById('quest-duration-display').textContent = formatDuration(0);
            todoTagsContainer.querySelector('input').checked = true; // Ensure at least one tag is checked
            
            // Reset daily quest UI
            document.getElementById('priority-container').style.display = 'block';
            document.getElementById('deadline-container').style.display = 'block';
            document.getElementById('todo-repeat-options-container').classList.add('hidden');
            todoPriorityInput.value = 'Mittel';
            document.getElementById('project-start-date').valueAsDate = new Date();
            
            // Reset duration input mode
            document.getElementById('Bearbeitungsdauer-Pomodoro').classList.remove('hidden');
            document.getElementById('Bearbeitungsdauer-Frei').classList.add('hidden');
            document.getElementById('duration-mode-toggle').textContent = 'Manuelle Eingabe';


            showQuestStep(1);
        }
        
        // Add event listeners for validation
        addTodoForm.addEventListener('input', validateCurrentQuestStep);
        addTodoForm.addEventListener('change', validateCurrentQuestStep);

        questNextBtn.addEventListener('click', () => {
            if (currentQuestStep < totalQuestSteps) {
                currentQuestStep++;
                showQuestStep(currentQuestStep);
            }
        });

        questBackBtn.addEventListener('click', () => {
             if (currentQuestStep > 1) {
                currentQuestStep--;
                showQuestStep(currentQuestStep);
            }
        });
        
        document.querySelectorAll('.duration-add-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                newQuestDuration += parseInt(btn.dataset.addDuration, 10);
                document.getElementById('quest-duration-display').textContent = formatDuration(newQuestDuration);
                validateCurrentQuestStep();
            });
        });
        document.getElementById('duration-reset-btn').addEventListener('click', () => {
             newQuestDuration = 0;
             document.getElementById('quest-duration-display').textContent = formatDuration(0);
             validateCurrentQuestStep();
        });
        
        document.getElementById('duration-mode-toggle').addEventListener('click', (e) => {
            const pomodoroContainer = document.getElementById('Bearbeitungsdauer-Pomodoro');
            const freeInputContainer = document.getElementById('Bearbeitungsdauer-Frei');
            const isPomodoroVisible = !pomodoroContainer.classList.contains('hidden');
            
            pomodoroContainer.classList.toggle('hidden', isPomodoroVisible);
            freeInputContainer.classList.toggle('hidden', !isPomodoroVisible);
            e.target.textContent = isPomodoroVisible ? 'Button-Eingabe' : 'Manuelle Eingabe';
            validateCurrentQuestStep();
        });

        toggleDetailsBtn.addEventListener('click', () => {
            detailsToggleContent.classList.toggle('hidden');
            toggleDetailsBtn.textContent = detailsToggleContent.classList.contains('hidden') ? 'Beschreibung hinzufügen +' : 'Beschreibung ausblenden -';
        });

        todoRepeatCheckbox.addEventListener('change', (e) => {
            const isChecked = e.target.checked;
            document.getElementById('todo-repeat-options-container').classList.toggle('hidden', !isChecked);
            document.getElementById('deadline-container').style.display = isChecked ? 'none' : 'block';
            document.getElementById('priority-container').style.display = isChecked ? 'none' : 'block';
            if (isChecked) {
                 todoPriorityInput.value = 'Leicht';
            }
            validateCurrentQuestStep();
        });

        addTodoForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const text = todoInput.value.trim();
            const selectedTag = todoTagsContainer.querySelector('input:checked')?.value;
            const isDaily = todoRepeatCheckbox.checked;
            const taskType = todoTaskTypeInput.value;

            // Final validation before submit
            if (!text || !selectedTag) {
                 showNotification("Bitte Titel und Tag ausfüllen.", "error"); return;
            }
            
            if (auth.currentUser) {
                const newQuest = {
                    userId: auth.currentUser.uid,
                    text: text,
                    priority: isDaily ? 'Leicht' : todoPriorityInput.value,
                    details: todoDetailsInput.value,
                    taskType: taskType,
                    tags: [selectedTag],
                    createdAt: serverTimestamp(),
                    isDaily: isDaily,
                    repeatDays: Array.from(todoRepeatDaysContainer.querySelectorAll('input:checked')).map(input => input.value),
                    startTime: isDaily ? todoStartTimeInput.value : null,
                };
                
                if (taskType === 'Projekt') {
                    const durationDays = parseInt(document.getElementById('project-duration-days').value, 10);
                    const startDate = new Date(document.getElementById('project-start-date').value);
                    if (isNaN(startDate.getTime()) || durationDays <= 0) {
                        showNotification("Bitte gültiges Startdatum und Dauer für das Projekt angeben.", "error"); return;
                    }
                    startDate.setHours(0,0,0,0);
                    newQuest.durationMinutes = durationDays * 24 * 60;
                    newQuest.ganttScheduledAt = Timestamp.fromDate(startDate);
                } else {
                    let durationInMinutes = 0;
                    const isFreeMode = !document.getElementById('Bearbeitungsdauer-Frei').classList.contains('hidden');
                    if (isFreeMode) {
                        durationInMinutes = parseDuration(document.getElementById('quest-duration-free-input').value);
                    } else {
                        durationInMinutes = newQuestDuration;
                    }

                    if (durationInMinutes <= 0) {
                         showNotification("Bitte eine Dauer von mehr als 0 Minuten angeben.", "error"); return;
                    }
                    newQuest.durationMinutes = durationInMinutes;
                    
                    let deadline;
                    if(isDaily) {
                        if (!todoStartTimeInput.value) {
                             showNotification("Bitte eine Startzeit für die tägliche Quest angeben.", "error"); return;
                        }
                        deadline = new Date();
                    } else {
                         if (!todoDeadlineInput.value) {
                             showNotification("Bitte eine Deadline angeben.", "error"); return;
                        }
                        deadline = new Date(todoDeadlineInput.value);
                    }
                    deadline.setHours(23, 59, 59, 999); // Set to end of day
                    newQuest.deadline = Timestamp.fromDate(deadline);
                }


                if (newQuest.taskType === 'Projektaufgabe' && todoParentProjectInput.value) {
                    newQuest.parentProjectId = todoParentProjectInput.value;
                }

                await addDoc(collection(db, 'todos'), newQuest);
                newQuestModal.classList.add('hidden');
            }
        });

        function populateParentProjectDropdown() {
            const projects = localQuests.filter(q => q.taskType === 'Projekt');
            todoParentProjectInput.innerHTML = '<option value="">Kein Projekt ausgewählt</option>';
            projects.forEach(p => {
                const option = document.createElement('option');
                option.value = p.id;
                option.textContent = p.text;
                todoParentProjectInput.appendChild(option);
            });
        }
        
        todoTaskTypeInput.addEventListener('change', (e) => {
            const taskType = e.target.value;
            const isProjectTask = taskType === 'Projektaufgabe';
            const isProject = taskType === 'Projekt';
            
            // Show/hide parent project dropdown
            todoParentProjectContainer.classList.toggle('hidden', !isProjectTask);
            if (isProjectTask) populateParentProjectDropdown();
            
            // Adjust wizard steps based on type
            document.getElementById('duration-container-task').classList.toggle('hidden', isProject);
            document.getElementById('duration-container-project').classList.toggle('hidden', !isProject);
            
            document.getElementById('deadline-container').classList.toggle('hidden', isProject);
            document.getElementById('start-date-container').classList.toggle('hidden', !isProject);
            document.getElementById('repeat-section').style.display = isProject ? 'none' : 'block';

            validateCurrentQuestStep();
        });

        async function handleQuestCompletion(questId) {
            const userId = auth.currentUser?.uid;
            if (!userId) return;

            const quest = localQuests.find(q => q.id === questId);
            if (!quest) return;

            if (quest.id === focusedQuestId) {
                focusedQuestId = null;
                resetFocusTimer();
            }

            const xpGained = getXpForPriority(quest.priority);
            const currencyRewards = { 'Leicht': 5, 'Mittel': 15, 'Schwer': 30 };
            let bronzeGained = currencyRewards[quest.priority] || 0;
            if(quest.isDaily) bronzeGained += 30;

            await addDoc(collection(db, 'users', userId, 'journal'), { ...quest, completedAt: serverTimestamp() });
            
            if(quest.isDaily) {
                await updateDoc(doc(db, 'todos', questId), { lastCompleted: serverTimestamp() });
            } else {
                await deleteDoc(doc(db, 'todos', questId));
            }
            
            showNotification(`Quest "${quest.text}" abgeschlossen! +${xpGained} XP & +${bronzeGained} Bronze`, 'success');
            
            await updateDoc(doc(db, 'users', userId), { 
                questsCompleted: increment(1),
                'currency.bronze': increment(bronzeGained)
            });
            const updatedUserProfile = (await getDoc(doc(db, 'users', userId))).data();
            await checkAndGrantAchievements(userId, updatedUserProfile);

            processQuestDrop(quest);
            
            await handleXpGain(userId, xpGained);
        }

        async function checkAndResetDailies(userId) {
            const userRef = doc(db, 'users', userId);
            const today = new Date();
            const todayStr = today.toISOString().split('T')[0];
            const yesterday = new Date();
            yesterday.setDate(today.getDate() - 1);
            
            const dayIndex = (today.getDay() + 6) % 7; // Monday = 0
            const yesterdayDayIndex = (yesterday.getDay() + 6) % 7;
            
            const batch = writeBatch(db);
            let hpPunishment = 0;

            for (const quest of localQuests) {
                if (!quest.isDaily) continue;

                const lastCompletedDate = quest.lastCompleted?.toDate();
                
                // Check for missed quest from yesterday
                const wasDueYesterday = (quest.repeatDays || []).includes(weekDays[yesterdayDayIndex]);
                const completedYesterday = lastCompletedDate && lastCompletedDate.toISOString().split('T')[0] === yesterday.toISOString().split('T')[0];

                if (wasDueYesterday && !completedYesterday) {
                    hpPunishment += 5; // Daily God-Bad Limits
                }

                // Reset deadline for today if it's a due day
                const isDueToday = (quest.repeatDays || []).includes(weekDays[dayIndex]);
                const deadlineDate = quest.deadline.toDate();
                
                if (isDueToday && deadlineDate.toISOString().split('T')[0] !== todayStr) {
                    const newDeadline = new Date();
                    newDeadline.setHours(23, 59, 59, 999);
                    batch.update(doc(db, 'todos', quest.id), { deadline: Timestamp.fromDate(newDeadline) });
                }
            }

            if (hpPunishment > 0) {
                const userDoc = await getDoc(userRef);
                const currentHp = userDoc.data().hp.current;
                const finalHp = Math.max(0, currentHp - hpPunishment);
                batch.update(userRef, { 'hp.current': finalHp });
                showNotification(`Du hast tägliche Quests verpasst! -${hpPunishment} HP`, 'error');
            }

            await batch.commit();
        }

        async function planQuestForToday(questId) {
             const userId = auth.currentUser?.uid;
            if (!userId) return;

            const quest = localQuests.find(q => q.id === questId);
            if (!quest) {
                showNotification("Quest nicht gefunden.", "error");
                return;
            }
            
            const ganttDate = new Date(document.getElementById('gantt-date').value);
            const [startHour, startMinute] = document.getElementById('gantt-start-time').value.split(':');
            ganttDate.setHours(startHour, startMinute, 0, 0);

            // Find next available time slot after the start time
             const scheduledToday = localQuests
                .filter(q => q.ganttScheduledAt)
                .map(q => ({...q, start: q.ganttScheduledAt.toDate().getTime(), end: q.ganttScheduledAt.toDate().getTime() + q.durationMinutes * 60000}))
                .sort((a,b) => a.start - b.start);

            let nextAvailableTime = ganttDate.getTime();
            
            for (const scheduled of scheduledToday) {
                if (nextAvailableTime >= scheduled.start && nextAvailableTime < scheduled.end) {
                    nextAvailableTime = scheduled.end;
                }
            }

            const questRef = doc(db, 'todos', questId);
            await updateDoc(questRef, { ganttScheduledAt: Timestamp.fromMillis(nextAvailableTime) });
            showNotification(`"${quest.text}" für heute geplant.`);
        }
        
        myQuestsModal.addEventListener('change', async (e) => {
            if (e.target.classList.contains('set-duration-input')) {
                const questId = e.target.dataset.id;
                const newDuration = parseInt(e.target.value, 10);
                if (questId && newDuration >= 10) {
                    await updateDoc(doc(db, 'todos', questId), { durationMinutes: newDuration });
                    showNotification("Dauer aktualisiert.");
                }
            }
        });
        
        myQuestsModal.addEventListener('click', async (e) => {
             const userId = auth.currentUser?.uid;
            if (!userId) return;

            if (e.target.classList.contains('complete-btn')) {
                handleQuestCompletion(e.target.dataset.id);
            }
            if (e.target.classList.contains('delete-btn')) {
                const todoId = e.target.dataset.id;
                if (confirm('Quest wirklich löschen?')) {
                    await deleteDoc(doc(db, 'todos', todoId));
                }
            }
            if (e.target.classList.contains('focus-btn')) {
                const questId = e.target.dataset.id;
                const questToFocus = localQuests.find(q => q.id === questId);
                
                if (questToFocus) {
                    startFocusSession(questToFocus);
                    myQuestsModal.classList.add('hidden'); // Close modal on focus
                }
            }
            if (e.target.classList.contains('plan-today-btn')) {
                 planQuestForToday(e.target.dataset.id);
            }
        });

        focusQuestContainer.addEventListener('click', e => {
             if (e.target.classList.contains('stop-focus-btn')) {
                focusedQuestId = null;
                resetFocusTimer();
                renderTodos();
                renderFocusQuest();
            }
            if (e.target.classList.contains('complete-btn')) {
                handleQuestCompletion(e.target.dataset.id);
            }
            if (e.target.classList.contains('accept-focus-btn')) {
                const questId = e.target.dataset.id;
                const questToFocus = localQuests.find(q => q.id === questId);
                if (questToFocus) {
                    startFocusSession(questToFocus);
                }
            }
            if (e.target.id === 'focus-timer-start-btn') {
                startFocusTimer();
            }
            if (e.target.id === 'focus-timer-pause-btn') {
                pauseFocusTimer();
            }
        });

        // --- Gantt Chart Logic ---
        const ganttDateInput = document.getElementById('gantt-date');
        ganttDateInput.valueAsDate = new Date();
        
        ganttControls.addEventListener('change', (e) => {
            if (e.target.id === 'gantt-auto-pause-toggle') {
                if (e.target.checked) {
                    handleAutoSchedule();
                } else {
                    ganttBreaks = [];
                    renderGanttChart();
                }
            } else {
                renderGanttChart();
            }
        });

        async function addManualBreak(questId, breakMinutes) {
            const quest = localQuests.find(q => q.id === questId);
            if (!quest || !quest.ganttScheduledAt) return;

            const breakDurationMillis = breakMinutes * 60 * 1000;
            const questEndTime = quest.ganttScheduledAt.toMillis() + (quest.durationMinutes * 60 * 1000);
            
            const subsequentQuests = localQuests
                .filter(q => q.ganttScheduledAt && q.ganttScheduledAt.toMillis() >= questEndTime)
                .sort((a,b) => a.ganttScheduledAt.toMillis() - b.ganttScheduledAt.toMillis());

            const batch = writeBatch(db);
            subsequentQuests.forEach(sq => {
                const questRef = doc(db, 'todos', sq.id);
                const newStartTime = Timestamp.fromMillis(sq.ganttScheduledAt.toMillis() + breakDurationMillis);
                batch.update(questRef, { ganttScheduledAt: newStartTime });
            });
            await batch.commit();

            ganttBreaks.push({
                id: `break_${Date.now()}`, type: 'break',
                ganttScheduledAt: Timestamp.fromMillis(questEndTime),
                durationMinutes: breakMinutes,
            });

            // Re-render immediately for better UX instead of waiting for onSnapshot
            renderGanttChart();
            showNotification(`${breakMinutes} Min Pause hinzugefügt.`, "success");
        }

        async function handleAutoSchedule() {
            ganttBreaks = []; // Always clear previous breaks when auto-scheduling
            const scheduledQuests = localQuests
                .filter(q => q.ganttScheduledAt && q.taskType !== 'Projekt')
                .sort((a, b) => a.ganttScheduledAt.toMillis() - b.ganttScheduledAt.toMillis());

            if (scheduledQuests.length < 2) {
                renderGanttChart(); // Re-render to show cleared breaks
                showNotification("Nicht genügend Aufgaben für automatische Pausen.", "info");
                return;
            }

            const batch = writeBatch(db);
            let totalShiftMillis = 0;
            const desiredBreakMinutes = 10;
            const desiredBreakMillis = desiredBreakMinutes * 60 * 1000;

            for (let i = 0; i < scheduledQuests.length; i++) {
                const currentQuest = scheduledQuests[i];
                const questRef = doc(db, 'todos', currentQuest.id);
                const originalStartTime = currentQuest.ganttScheduledAt.toMillis();
                
                let newStartTime = originalStartTime;
                if (totalShiftMillis > 0) {
                    newStartTime += totalShiftMillis;
                    batch.update(questRef, { ganttScheduledAt: Timestamp.fromMillis(newStartTime) });
                }
                
                const questEndTime = newStartTime + currentQuest.durationMinutes * 60000;

                if (i < scheduledQuests.length - 1) {
                    ganttBreaks.push({
                        id: `auto_break_${currentQuest.id}`, type: 'break',
                        ganttScheduledAt: Timestamp.fromMillis(questEndTime),
                        durationMinutes: desiredBreakMinutes
                    });
                    
                    const nextQuestOriginalStart = scheduledQuests[i+1].ganttScheduledAt.toMillis();
                    // This calculation is tricky with accumulated shifts, so we simplify by just adding the break time
                    totalShiftMillis += desiredBreakMillis;
                }
            }

            await batch.commit();
            // The onSnapshot listener will eventually call renderGanttChart, 
            // but we call it here for immediate feedback.
            renderGanttChart();
            showNotification("Pausen wurden automatisch geplant und Quests verschoben.", "success");
        }
        
        function populateGanttProjectFilter() {
            const projectFilter = document.getElementById('gantt-project-filter');
            const projects = localQuests.filter(q => q.taskType === 'Projekt');
            projectFilter.innerHTML = '<option value="">Alle</option>';
            projects.forEach(p => {
                const option = document.createElement('option');
                option.value = p.id;
                option.textContent = p.text;
                projectFilter.appendChild(option);
            });
        }

        function checkGanttAutoFocus() {
            const now = new Date().getTime();
            
            const activeQuests = localQuests.filter(q => {
                if (!q.ganttScheduledAt || !q.durationMinutes) return false;
                const startTime = q.ganttScheduledAt.toMillis();
                const endTime = startTime + q.durationMinutes * 60000;
                return now >= startTime && now < endTime;
            });

            if (activeQuests.length > 1) {
                showNotification("Konflikt: Mehrere Quests sind für die aktuelle Zeit geplant!", "error");
                return;
            }
            
            if (activeQuests.length === 1) {
                const newFocusId = activeQuests[0].id;
                if (focusedQuestId !== newFocusId) {
                    const questToFocus = localQuests.find(q => q.id === newFocusId);
                    if (questToFocus) startFocusSession(questToFocus);
                }
            }
        }

        function renderGanttChart() {
            ganttChartContainer.innerHTML = '';
            const viewMode = document.getElementById('gantt-view-select').value;
            const viewDate = new Date(ganttDateInput.value);
            const [startHour, startMinute] = document.getElementById('gantt-start-time').value.split(':');
            viewDate.setHours(startHour, startMinute, 0, 0);
            
            const scheduledQuests = localQuests
                .filter(q => q.ganttScheduledAt && q.durationMinutes)
                .map(q => ({...q, ganttScheduledAt: q.ganttScheduledAt.toDate()}));

            const allScheduledItems = [
                ...scheduledQuests, 
                ...ganttBreaks.map(b => ({...b, ganttScheduledAt: b.ganttScheduledAt.toDate()}))
            ];
            
            if (viewMode === 'single-line') {
                 renderGanttSingleLineView(allScheduledItems, new Date(viewDate), 8 * 60);
                 return;
            }

            if (allScheduledItems.length === 0) {
                ganttChartContainer.innerHTML = '<p class="col-span-2 text-center text-gray-400">Keine Quests für diesen Zeitraum geplant.</p>';
                return;
            }
            
            let viewStart, viewEnd;
            let totalDurationMinutes;
            const timelineHeader = document.createElement('div');
            timelineHeader.className = 'grid border-b border-gray-600 sticky top-0 bg-gray-800 z-10';
            const labelHeader = `<div class="font-bold border-b border-gray-600 p-2 sticky top-0 bg-gray-800 z-10">Quest</div>`;
            
            const selectedProjectId = document.getElementById('gantt-project-filter').value;
            if (selectedProjectId) {
                const project = scheduledQuests.find(q => q.id === selectedProjectId);
                if (project) {
                    viewStart = project.ganttScheduledAt;
                    viewEnd = new Date(viewStart.getTime() + project.durationMinutes * 60000);
                    totalDurationMinutes = project.durationMinutes;
                    
                    const numColumns = Math.max(1, Math.ceil(totalDurationMinutes / (24 * 60))); 
                    timelineHeader.style.gridTemplateColumns = `repeat(${numColumns}, 1fr)`;
                    for (let i = 0; i < numColumns; i++) {
                         const time = new Date(viewStart.getTime() + i * 24 * 60 * 60000);
                         const timeEl = document.createElement('div');
                         timeEl.className = 'text-center text-xs p-1 border-r border-gray-700';
                         timeEl.textContent = time.toLocaleDateString('de-DE', { month: 'short', day: 'numeric' });
                         timelineHeader.appendChild(timeEl);
                    }
                }
            }

            if (!viewStart) { 
                if (viewMode === 'day') {
                    viewStart = new Date(viewDate);
                    viewEnd = new Date(viewStart);
                    viewEnd.setHours(viewEnd.getHours() + 8); 
                    totalDurationMinutes = 8 * 60;
                    const columns = 16;
                    timelineHeader.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;
                    for (let i = 0; i < columns; i++) {
                        const time = new Date(viewStart.getTime() + i * 30 * 60000);
                        const timeEl = document.createElement('div');
                        timeEl.className = 'text-center text-xs p-1 border-r border-gray-700';
                        timeEl.textContent = time.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
                        timelineHeader.appendChild(timeEl);
                    }
                } else { 
                    viewStart = new Date(viewDate);
                    viewStart.setDate(viewStart.getDate() - viewStart.getDay() + 1); 
                    viewStart.setHours(0,0,0,0);
                    viewEnd = new Date(viewStart);
                    viewEnd.setDate(viewEnd.getDate() + 7);
                    totalDurationMinutes = 7 * 24 * 60;
                    timelineHeader.style.gridTemplateColumns = `repeat(7, 1fr)`;
                    for (let i = 0; i < 7; i++) {
                        const day = new Date(viewStart.getTime() + i * 24 * 60 * 60000);
                        const dayEl = document.createElement('div');
                        dayEl.className = 'text-center text-xs p-1 border-r border-gray-700';
                        dayEl.textContent = day.toLocaleDateString('de-DE', { weekday: 'short', day: '2-digit' });
                        dayEl.appendChild(dayEl);
                    }
                }
            }
            
            ganttChartContainer.innerHTML = labelHeader;
            ganttChartContainer.appendChild(timelineHeader);

            const itemsToDisplay = allScheduledItems.sort((a, b) => a.ganttScheduledAt - b.ganttScheduledAt);

            itemsToDisplay.forEach((item, index) => {
                const isProject = item.taskType === 'Projekt';
                const isSubTask = !!item.parentProjectId;
                const isBreak = item.type === 'break';

                const label = document.createElement('div');
                label.className = `truncate p-2 border-b border-gray-700 ${isSubTask ? 'pl-8' : ''} ${isBreak ? 'text-gray-400 pl-8 italic' : ''}`;
                label.textContent = isBreak ? `Pause (${item.durationMinutes} Min)` : item.text;
                label.title = isBreak ? `${item.durationMinutes} Min Pause` : item.text;
                ganttChartContainer.appendChild(label);

                const timelineRow = document.createElement('div');
                timelineRow.className = 'border-b border-gray-700 relative';
                timelineRow.dataset.questId = item.id;
                ganttChartContainer.appendChild(timelineRow);
                
                const itemStart = item.ganttScheduledAt.getTime();
                const itemEnd = itemStart + item.durationMinutes * 60000;

                if (itemEnd < viewStart.getTime() || itemStart > viewEnd.getTime()) return;

                const startOffsetMinutes = Math.max(0, (itemStart - viewStart.getTime()) / 60000);
                const endOffsetMinutes = Math.min(totalDurationMinutes, (itemEnd - viewStart.getTime()) / 60000);
                const durationInViewMinutes = endOffsetMinutes - startOffsetMinutes;

                if (durationInViewMinutes <= 0) return;

                const bar = document.createElement('div');
                bar.style.left = `${(startOffsetMinutes / totalDurationMinutes) * 100}%`;
                bar.style.width = `${(durationInViewMinutes / totalDurationMinutes) * 100}%`;
                
                if (isBreak) {
                    bar.className = 'gantt-quest-bar bg-gray-500 opacity-70 flex items-center justify-end pr-1';
                    bar.innerHTML = `<button data-break-id="${item.id}" class="delete-break-btn text-white font-bold leading-none p-1 text-xs hover:bg-red-500 rounded-full">x</button>`;
                } else {
                    const priorityColors = { 'Leicht': 'bg-green-600', 'Mittel': 'bg-yellow-600', 'Schwer': 'bg-red-600' };
                    bar.className = `gantt-quest-bar ${priorityColors[item.priority] || 'bg-blue-600'} ${isProject ? 'project' : ''}`;
                    bar.title = `${item.text} (${item.durationMinutes} Min)`;
                    bar.draggable = true;
                    bar.dataset.questId = item.id;

                    const textSpan = document.createElement('span');
                    textSpan.className = 'truncate';
                    textSpan.textContent = isProject ? '' : item.text;
                    bar.appendChild(textSpan);
                    
                    const isAutoPauseEnabled = document.getElementById('gantt-auto-pause-toggle').checked;
                    const nextItem = itemsToDisplay[index + 1];
                    const hasFollowingBreak = nextItem && nextItem.type === 'break' && nextItem.ganttScheduledAt.getTime() === itemEnd;

                    if (!isProject && !isAutoPauseEnabled && !hasFollowingBreak) {
                        const buttonsDiv = document.createElement('div');
                        buttonsDiv.className = "gantt-break-buttons absolute right-1 top-1/2 -translate-y-1/2 flex gap-1";
                        buttonsDiv.innerHTML = `<div class="gantt-break-buttons absolute right-1 top-1/2 -translate-y-1/2 flex gap-1">
                            <button data-add-break="5" class="text-xs bg-blue-800 rounded-full w-5 h-5 leading-none hover:bg-blue-600">+5</button>
                            <button data-add-break="10" class="text-xs bg-blue-800 rounded-full w-5 h-5 leading-none hover:bg-blue-600">+10</button>
                        </div>`;
                        bar.appendChild(buttonsDiv);
                    }
                }
                timelineRow.appendChild(bar);
            });

            addGanttDragDropListeners(viewStart, totalDurationMinutes);
        }
        
        function renderGanttSingleLineView(items, viewStart, totalViewMinutes) {
             const labelHeader = `<div class="font-bold border-b border-gray-600 p-2 sticky top-0 bg-gray-800 z-10">Alle Quests</div>`;
             const timelineHeader = document.createElement('div');
             timelineHeader.className = 'grid border-b border-gray-600 sticky top-0 bg-gray-800 z-10';
             const columns = 16;
             timelineHeader.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;
             for (let i = 0; i < columns; i++) {
                 const time = new Date(viewStart.getTime() + i * 30 * 60000);
                 const timeEl = document.createElement('div');
                 timeEl.className = 'text-center text-xs p-1 border-r border-gray-700';
                 timeEl.textContent = time.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
                 timelineHeader.appendChild(timeEl);
             }

             ganttChartContainer.innerHTML = labelHeader;
             ganttChartContainer.appendChild(timelineHeader);
             
             const timelineRowPlaceholder = document.createElement('div'); 
             const timelineRow = document.createElement('div');
             timelineRow.className = 'border-b border-gray-700 relative h-10';
             ganttChartContainer.appendChild(timelineRowPlaceholder);
             ganttChartContainer.appendChild(timelineRow);

             const viewStartMs = viewStart.getTime();
             const viewEndMs = viewStartMs + totalViewMinutes * 60000;
             
             const itemsInView = items
                .filter(q => (q.ganttScheduledAt.getTime() + q.durationMinutes * 60000) > viewStartMs && q.ganttScheduledAt.getTime() < viewEndMs)
                .sort((a,b) => a.ganttScheduledAt - b.ganttScheduledAt);
             
             itemsInView.forEach((item, index) => {
                const isBreak = item.type === 'break';
                const itemStart = item.ganttScheduledAt.getTime();
                const itemEnd = itemStart + item.durationMinutes * 60000;
                
                const startOffsetMinutes = Math.max(0, (itemStart - viewStartMs) / 60000);
                const endOffsetMinutes = Math.min(totalViewMinutes, (itemEnd - viewStartMs) / 60000);
                const durationInViewMinutes = endOffsetMinutes - startOffsetMinutes;

                if (durationInViewMinutes <= 0) return;

                const bar = document.createElement('div');
                bar.style.left = `${(startOffsetMinutes / totalViewMinutes) * 100}%`;
                bar.style.width = `${(durationInViewMinutes / totalViewMinutes) * 100}%`;

                if (isBreak) {
                    bar.className = 'gantt-quest-bar bg-gray-500 opacity-70 flex items-center justify-end pr-1';
                    bar.innerHTML = `<button data-break-id="${item.id}" class="delete-break-btn text-white font-bold leading-none p-1 text-xs hover:bg-red-500 rounded-full">x</button>`;
                } else {
                    const priorityColors = { 'Leicht': 'bg-green-600', 'Mittel': 'bg-yellow-600', 'Schwer': 'bg-red-600' };
                    bar.className = `gantt-quest-bar ${priorityColors[item.priority] || 'bg-blue-600'}`;
                    bar.title = `${item.text} (${item.durationMinutes} Min)`;
                    bar.draggable = true;
                    bar.dataset.questId = item.id;
                    
                    const textSpan = document.createElement('span');
                    textSpan.className = 'truncate';
                    textSpan.textContent = item.text;
                    bar.appendChild(textSpan);
                    
                    const isAutoPauseEnabled = document.getElementById('gantt-auto-pause-toggle').checked;
                    const nextItem = itemsInView[index + 1];
                    const hasFollowingBreak = nextItem && nextItem.type === 'break' && nextItem.ganttScheduledAt.getTime() === itemEnd;
                    
                    if (!isAutoPauseEnabled && !hasFollowingBreak) {
                        const buttonsDiv = document.createElement('div');
                        buttonsDiv.className = "gantt-break-buttons absolute right-1 top-1/2 -translate-y-1/2 flex gap-1";
                        buttonsDiv.innerHTML = `<button data-add-break="5" class="text-xs bg-blue-800 rounded-full w-5 h-5 leading-none hover:bg-blue-600">+5</button>
                                                <button data-add-break="10" class="text-xs bg-blue-800 rounded-full w-5 h-5 leading-none hover:bg-blue-600">+10</button>`;
                        bar.appendChild(buttonsDiv);
                    }
                }
                timelineRow.appendChild(bar);
             });
             
             for(let i = 0; i < itemsInView.length; i++) {
                 for(let j = i + 1; j < itemsInView.length; j++) {
                     const itemA = itemsInView[i];
                     const itemB = itemsInView[j];
                     if (itemA.type === 'break' || itemB.type === 'break') continue;

                     const startA = itemA.ganttScheduledAt.getTime();
                     const endA = startA + itemA.durationMinutes * 60000;
                     const startB = itemB.ganttScheduledAt.getTime();
                     const endB = startB + itemB.durationMinutes * 60000;
                     const overlapStart = Math.max(startA, startB);
                     const overlapEnd = Math.min(endA, endB);

                     if (overlapStart < overlapEnd) {
                        const startOffsetMinutes = (overlapStart - viewStartMs) / 60000;
                        const durationMinutes = (overlapEnd - overlapStart) / 60000;
                        if (startOffsetMinutes >= 0 && durationMinutes > 0) {
                             const conflictSegment = document.createElement('div');
                             conflictSegment.className = 'gantt-conflict-segment';
                             conflictSegment.style.left = `${(startOffsetMinutes / totalViewMinutes) * 100}%`;
                             conflictSegment.style.width = `${(durationMinutes / totalViewMinutes) * 100}%`;
                             timelineRow.appendChild(conflictSegment);
                        }
                     }
                 }
             }
             addGanttDragDropListeners(viewStart, totalViewMinutes);
        }


        function addGanttDragDropListeners(viewStartDate, totalViewMinutes) {
            const draggableBars = ganttChartContainer.querySelectorAll('.gantt-quest-bar[draggable="true"]');
            const dropTargets = ganttChartContainer.querySelectorAll('.border-b.relative');

            draggableBars.forEach(bar => {
                bar.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', e.target.dataset.questId);
                    e.target.style.opacity = '0.5';
                });
                bar.addEventListener('dragend', (e) => {
                    e.target.style.opacity = '1';
                });
            });

            dropTargets.forEach(target => {
                target.addEventListener('dragover', (e) => e.preventDefault());
                target.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    const questId = e.dataTransfer.getData('text/plain');
                    const quest = localQuests.find(q => q.id === questId);
                    if (!quest) return;
                    
                    const timelineRect = e.currentTarget.getBoundingClientRect();
                    const pixelOffset = e.clientX - timelineRect.left;
                    const timeOffsetMinutes = (pixelOffset / timelineRect.width) * totalViewMinutes;
                    
                    let newStartTime = new Date(viewStartDate.getTime() + timeOffsetMinutes * 60000);
                    
                    if (document.getElementById('gantt-view-select').value === 'day') {
                        const minutes = newStartTime.getMinutes();
                        const roundedMinutes = Math.round(minutes / 15) * 15;
                        newStartTime.setMinutes(roundedMinutes, 0, 0);
                    }
                    
                    const questRef = doc(db, 'todos', questId);
                    await updateDoc(questRef, { ganttScheduledAt: Timestamp.fromDate(newStartTime) });
                    showNotification(`"${quest.text}" verschoben.`);
                });
            });
        }

        ganttChartContainer.addEventListener('click', async (e) => {
            const addBreakBtn = e.target.closest('button[data-add-break]');
            if (addBreakBtn) {
                const questId = addBreakBtn.closest('.gantt-quest-bar').dataset.questId;
                const breakMinutes = parseInt(addBreakBtn.dataset.addBreak, 10);
                await addManualBreak(questId, breakMinutes);
                return;
            }
            
            const deleteBreakBtn = e.target.closest('button.delete-break-btn');
            if (deleteBreakBtn) {
                const breakId = deleteBreakBtn.dataset.breakId;
                ganttBreaks = ganttBreaks.filter(b => b.id !== breakId);
                renderGanttChart();
                return;
            }
        });


        // --- Pomodoro Timer Logic ---
        function updateTimerDisplay() {
            const minutes = Math.floor(timeLeftInSeconds / 60);
            const seconds = timeLeftInSeconds % 60;
            timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function selectTime(minutes, mode) {
            if (timerInterval) {
                showNotification("Bitte pausiere oder resete den laufenden Timer zuerst.", "error");
                return;
            }
            resetTimer();
            defaultTime = minutes * 60;
            timeLeftInSeconds = defaultTime;
            timerModeDisplay.textContent = `Modus: ${mode}`;
            updateTimerDisplay();
        }

        function pauseTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
                isTimerPaused = true;
            }
        }

        function resetTimer() {
            pauseTimer();
            timeLeftInSeconds = defaultTime;
            updateTimerDisplay();
        }

        async function startTimer() {
            if (timerInterval || timeLeftInSeconds <= 0) return;
            isTimerPaused = false;
            
            timerInterval = setInterval(async () => {
                timeLeftInSeconds--;
                updateTimerDisplay();

                if (timeLeftInSeconds < 0) {
                    pauseTimer();
                    showNotification("Zeit ist um!", "success");
                    resetTimer();
                    
                    const userId = auth.currentUser?.uid;
                    if(userId) {
                        const userDocRef = doc(db, 'users', userId);
                        await updateDoc(userDocRef, { pomodorosCompleted: increment(1) });
                        const updatedUserProfile = (await getDoc(userDocRef)).data();
                        await checkAndGrantAchievements(userId, updatedUserProfile);
                    }
                }
            }, 1000);
        }

        timerStartBtn.addEventListener('click', startTimer);
        timerPauseBtn.addEventListener('click', pauseTimer);
        timerResetBtn.addEventListener('click', resetTimer);
        timerSelectBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const minutes = parseInt(btn.dataset.minutes, 10);
                const mode = btn.dataset.mode;
                selectTime(minutes, mode);
            });
        });
        
        // --- Pet Logic ---
        function renderActivePetsSidebar(userProfile) {
            if (!activePetsSidebar) return;
            activePetsSidebar.innerHTML = '';
            const allPets = userProfile.pets || {};
            const activePetIds = userProfile.activePets || [];

            for(let i = 0; i < 3; i++) {
                const petId = activePetIds[i];
                if (petId && allPets[petId]) {
                    const pet = allPets[petId];
                    const petEl = document.createElement('div');
                    petEl.className = 'w-8 h-8 flex items-center justify-center bg-gray-700 rounded-full border-2 border-purple-500';
                    petEl.innerHTML = `<span class="text-lg" title="${pet.name} (Lvl ${pet.level})">${pet.icon}</span>`;
                    activePetsSidebar.appendChild(petEl);
                } else {
                    const slotEl = document.createElement('div');
                    slotEl.className = 'w-8 h-8 bg-gray-900 rounded-full border-2 border-gray-600';
                    activePetsSidebar.appendChild(slotEl);
                }
            }
        }
        
        function renderPets(userProfile) {
            if (!userProfile) return;
            renderPetInventoryList(userProfile);
            renderPetDetailsView(userProfile);
        }
        
        function renderPetInventoryList(userProfile) {
            const allPets = Object.values(userProfile.pets || {});
            const activePetIds = userProfile.activePets || [];

            const filteredPets = allPets.filter(pet => {
                const elementMatch = petFilters.element === 'all' || pet.element === petFilters.element;
                const rarityMatch = petFilters.rarity === 'all' || pet.rarity === petFilters.rarity;
                const isNotActive = !activePetIds.includes(pet.docId);
                return elementMatch && rarityMatch && isNotActive;
            });

            const totalPages = Math.max(1, Math.ceil(filteredPets.length / petsItemsPerPage));
            petsCurrentPage = Math.min(petsCurrentPage, totalPages);
            const startIndex = (petsCurrentPage - 1) * petsItemsPerPage;
            const itemsToShow = filteredPets.slice(startIndex, startIndex + petsItemsPerPage);

            petsInventoryList.innerHTML = '';
            itemsToShow.forEach(pet => {
                const petEl = document.createElement('div');
                const borderColor = rarityColors[pet.rarity] || 'border-gray-500';
                const isSelected = selectedInventoryPetId === pet.docId;
                petEl.className = `p-2 border-2 rounded-lg flex items-center gap-3 cursor-pointer transition ${borderColor} ${isSelected ? 'bg-blue-800' : 'hover:bg-gray-700'}`;
                petEl.dataset.petId = pet.docId;

                const rarity = rarityTiers[pet.rarity] || rarityTiers.common;
                petEl.innerHTML = `
                    <span class="text-3xl">${pet.icon}</span>
                    <div>
                        <p class="font-bold ${rarity.color}">${pet.name}</p>
                        <p class="text-xs text-gray-400">Lvl ${pet.level} - ${pet.element}</p>
                    </div>
                `;
                petsInventoryList.appendChild(petEl);
            });
            
            petsPageInfo.textContent = `Seite ${petsCurrentPage} / ${totalPages}`;
            petsPagePrev.disabled = petsCurrentPage === 1;
            petsPageNext.disabled = petsCurrentPage >= totalPages;
        }

        function renderPetDetailsView(userProfile) {
            petsDetailsView.innerHTML = '';
            const allPets = userProfile.pets || {};
            const activePetIds = userProfile.activePets || [];
            let petToDisplay = null; // The active pet being shown/compared against
            let petToCompare = null; // The selected inventory pet
            let viewMode = 'active'; // 'active' or 'compare'

            if (selectedInventoryPetId) {
                viewMode = 'compare';
                petToCompare = allPets[selectedInventoryPetId];
                if (activePetIds.length > 0) {
                    const activePetId = activePetIds[comparedActivePetSlotIndex];
                    petToDisplay = allPets[activePetId];
                }
            } else {
                 if (activePetIds.length > 0) {
                    const activePetId = activePetIds[comparedActivePetSlotIndex];
                    petToDisplay = allPets[activePetId];
                 }
            }

            if (!petToDisplay && !petToCompare) {
                petsDetailsView.innerHTML = '<p class="text-center text-gray-400 m-auto">Kein Pet ausgewählt oder aktiv.</p>';
                return;
            }
            
            let html = '<div class="flex-grow flex flex-col">';
            
            const nextButtonHtml = activePetIds.length > 1 
                ? `<button id="next-active-pet-btn" class="self-end text-xs bg-gray-600 hover:bg-gray-500 p-1 rounded mb-2">Nächstes &gt;&gt;</button>` 
                : '';
            
            if (viewMode === 'active') html += nextButtonHtml;

            html += `<div class="flex-grow flex gap-4">`;
            if (viewMode === 'compare') {
                html += petToDisplay ? generatePetDetailColumn(petToDisplay, 'Aktiv (Slot ' + (comparedActivePetSlotIndex + 1) + ')', petToCompare) : generatePetDetailColumn(null, 'Leerer Slot ' + (comparedActivePetSlotIndex + 1));
                html += generatePetDetailColumn(petToCompare, 'Auswahl', petToDisplay);
                 if (activePetIds.length > 1) {
                    html += `<div class="absolute top-1/2 -translate-y-1/2 right-2"><button id="next-active-pet-btn" class="text-lg bg-gray-600 hover:bg-gray-500 p-2 rounded-full leading-none">&gt;&gt;</button></div>`;
                }
            } else {
                 html += petToDisplay ? generatePetDetailColumn(petToDisplay, 'Aktiv (Slot ' + (comparedActivePetSlotIndex + 1) + ')') : generatePetDetailColumn(null, 'Leerer Slot');
            }
            html += `</div>`;
            
            html += `<div class="mt-4 flex-shrink-0 flex gap-2 justify-end border-t border-gray-700 pt-3">`;
            if (viewMode === 'compare' && petToCompare) {
                html += `<button data-action="release-pet" data-pet-id="${petToCompare.docId}" class="text-sm bg-red-800 hover:bg-red-700 rounded px-3 py-1">Freilassen</button>`;
                html += `<button data-action="swap-pet" class="text-sm bg-green-600 hover:bg-green-500 rounded px-3 py-1">Mitnehmen</button>`;
            } else if (petToDisplay) {
                html += `<button data-action="unequip-pet" data-pet-id="${petToDisplay.docId}" class="text-sm bg-yellow-600 hover:bg-yellow-500 rounded px-3 py-1">Ausrüstung ablegen</button>`;
            }
            html += `</div></div>`;
            
            petsDetailsView.innerHTML = html;
        }
        
        function generatePetDetailColumn(pet, title, comparePet = null) {
            if (!pet) return `<div class="flex-1 text-center p-4"><h4 class="text-lg font-bold text-gray-500 mb-2">${title}</h4><div class="text-6xl p-4">?</div><p class="text-gray-500">Nichts ausgerüstet</p></div>`;
            
            const rarity = rarityTiers[pet.rarity] || rarityTiers.common;
            const petStats = pet.currentStats || pet.baseStats || {};
            const compareStats = comparePet?.currentStats || comparePet?.baseStats || {};
            const allStatKeys = new Set([...Object.keys(petStats), ...Object.keys(compareStats)]);
            
            let bonusesHtml = '';
            for (const stat of allStatKeys) {
                const petVal = petStats[stat] || 0;
                let colorClass = 'text-green-400';
                
                if (comparePet) {
                    const compareVal = compareStats[stat] || 0;
                    if (petVal > compareVal) colorClass = 'text-green-400';
                    else if (petVal < compareVal) colorClass = 'text-red-400';
                    else colorClass = 'text-gray-300';
                }
                
                if (typeof petStats[stat] !== 'undefined') {
                    bonusesHtml += `<li><span class="capitalize">${stat}:</span> <span class="font-bold ${colorClass}">${petVal}</span></li>`;
                }
            }
            
            const xpPercentage = pet.maxXp > 0 ? (pet.xp / pet.maxXp) * 100 : 0;

            return `
                <div class="flex-1 text-center p-2 flex flex-col">
                    ${title ? `<h4 class="text-lg font-bold text-gray-400 mb-2">${title}</h4>` : ''}
                    <div class="text-8xl">${pet.icon}</div>
                    <h3 class="text-xl font-bold mt-2 ${rarity.color}">${pet.name}</h3>
                    <p class="text-sm text-gray-400">Level ${pet.level} ${rarity.name} - ${pet.element}</p>
                    <div class="w-full bg-gray-700 rounded-full h-1.5 my-2 border border-gray-600">
                        <div class="bg-yellow-400 h-full rounded-full" style="width: ${xpPercentage}%" title="${pet.xp} / ${pet.maxXp} XP"></div>
                    </div>
                    <ul class="text-left mt-2 text-sm space-y-1 bg-gray-800 p-3 rounded-lg flex-grow">${bonusesHtml || '<li class="text-gray-400">Keine Boni</li>'}</ul>
                    <div class="mt-3 bg-gray-800 p-2 rounded-lg">
                        <h5 class="text-xs font-bold text-gray-400 mb-1">Fähigkeiten</h5>
                        <p class="text-xs text-gray-300">${(pet.skills || []).join(', ')}</p>
                    </div>
                </div>
            `;
        }

        async function swapPet() {
            const userId = auth.currentUser.uid;
            if (!selectedInventoryPetId) return;
            const userDocRef = doc(db, 'users', userId);

            let activePets = [...(currentUserProfile.activePets || [])];
            const petToEquipId = selectedInventoryPetId;

            if (activePets.length < 3) {
                 activePets.push(petToEquipId);
            } else {
                activePets[comparedActivePetSlotIndex] = petToEquipId;
            }
            
            await updateDoc(userDocRef, { activePets });
            selectedInventoryPetId = null;
            comparedActivePetSlotIndex = 0;
            showNotification("Pet ausgetauscht!", "success");
        }

        async function unequipPet(petId) {
            const userId = auth.currentUser.uid;
            await updateDoc(doc(db, 'users', userId), { activePets: arrayRemove(petId) });
            selectedInventoryPetId = null;
            comparedActivePetSlotIndex = 0;
            showNotification("Pet abgelegt.", "info");
        }
        
        async function releasePet() {
            const userId = auth.currentUser.uid;
            if (!petToReleaseId || !userId) return;

            if ((currentUserProfile.activePets || []).includes(petToReleaseId)) {
                showNotification("Aktive Pets können nicht freigelassen werden.", "error");
                petToReleaseId = null;
                deleteConfirmModal.classList.add('hidden');
                return;
            }

            const petName = currentUserProfile.pets?.[petToReleaseId]?.name || "Pet";
            await updateDoc(doc(db, 'users', userId), { [`pets.${petToReleaseId}`]: deleteField() });
            
            showNotification(`${petName} wurde freigelassen.`, "info");
            petToReleaseId = null;
            selectedInventoryPetId = null;
            deleteConfirmModal.classList.add('hidden');
        }

        async function gainPetXp(petId, amount) {
            const userId = auth.currentUser?.uid;
            if (!userId || !petId) return;
            const userDocRef = doc(db, 'users', userId);
        
            try {
                await runTransaction(db, async (transaction) => {
                    const userDoc = await transaction.get(userDocRef);
                    if (!userDoc.exists()) throw "User document does not exist!";
        
                    const userData = userDoc.data();
                    let pet = userData.pets?.[petId];
                    if (!pet) throw `Pet with ID ${petId} not found!`;
        
                    pet.xp += amount;
        
                    let leveledUp = false;
                    while (pet.xp >= pet.maxXp) {
                        leveledUp = true;
                        pet = levelUpPet(pet); // Pass the whole pet object
                    }
        
                    const updatePayload = { [`pets.${petId}`]: pet };
                    transaction.update(userDocRef, updatePayload);
        
                    if (leveledUp) {
                        showNotification(`${pet.name} ist auf Level ${pet.level} aufgestiegen!`, "success");
                    }
                });
            } catch (error) {
                console.error("Pet XP Transaction failed: ", error);
            }
        }
        
        function levelUpPet(pet) {
            pet.xp -= pet.maxXp;
            pet.level += 1;
            pet.maxXp = pet.level * 100;
        
            // Placeholder-Logik für Stat-Erhöhung.
            // Dies wird später durch eine detaillierte Logik ersetzt (z.B. aus einer CSV/Backend).
            const possibleStats = Object.keys(pet.currentStats);
            if (possibleStats.length > 0) {
                const randomStat = possibleStats[Math.floor(Math.random() * possibleStats.length)];
                pet.currentStats[randomStat] += 1;
            }
        
            return pet;
        }

        petsInventoryList.addEventListener('click', e => {
            const petEl = e.target.closest('[data-pet-id]');
            if (petEl) {
                selectedInventoryPetId = petEl.dataset.petId;
                comparedActivePetSlotIndex = 0;
                renderPets(currentUserProfile);
            }
        });

        petsDetailsView.addEventListener('click', async e => {
            const button = e.target.closest('button');
            if (!button) return;

            if (button.id === 'next-active-pet-btn') {
                const activeCount = currentUserProfile.activePets.length;
                if(activeCount > 0) {
                    comparedActivePetSlotIndex = (comparedActivePetSlotIndex + 1) % activeCount;
                    renderPetDetailsView(currentUserProfile);
                }
                return;
            }

            const { action, petId } = button.dataset;
            if (!action || !auth.currentUser) return;
            
            if (action === 'swap-pet') await swapPet();
            if (action === 'unequip-pet') await unequipPet(petId);
            if (action === 'release-pet') {
                petToReleaseId = petId;
                itemToDeleteId = null;
                const petName = currentUserProfile.pets?.[petToReleaseId]?.name || "dieses Pet";
                deleteConfirmText.textContent = `Willst du "${petName}" wirklich freilassen? Dies kann nicht rückgängig gemacht werden.`;
                deleteConfirmModal.classList.add('hidden');
            }
        });
        
        [petFilterElement, petFilterRarity].forEach(el => el.addEventListener('change', () => {
            petFilters.element = petFilterElement.value;
            petFilters.rarity = petFilterRarity.value;
            petsCurrentPage = 1;
            renderPetInventoryList(currentUserProfile);
        }));

        petsPagePrev.addEventListener('click', () => {
            if (petsCurrentPage > 1) {
                petsCurrentPage--;
                renderPetInventoryList(currentUserProfile);
            }
        });
        petsPageNext.addEventListener('click', () => {
             const allPets = Object.values(currentUserProfile.pets || {});
             const totalPages = Math.ceil(allPets.length / petsItemsPerPage);
             if (petsCurrentPage < totalPages) {
                petsCurrentPage++;
                renderPetInventoryList(currentUserProfile);
             }
        });


        // --- Utility ---
        function showNotification(message, type = 'info', duration = 3000) {
            const colors = { 'info': 'bg-blue-500', 'success': 'bg-green-500', 'error': 'bg-red-500' };
            notificationArea.textContent = message;
            notificationArea.className = `fixed top-5 right-5 text-white p-3 rounded-lg shadow-lg transition-opacity duration-500 z-50 ${colors[type] || colors.info}`;
            notificationArea.style.opacity = '1';
            setTimeout(() => { notificationArea.style.opacity = '0'; }, duration);
        }

        // --- Potion Buttons ---
        useHpPotionBtn.addEventListener('click', () => {
            const hpPotion = allInventoryItems.find(item => item.id === 'potion_hp_small');
            if (hpPotion && auth.currentUser) {
                useItem(auth.currentUser.uid, hpPotion.docId);
            } else {
                showNotification("Keine Heiltränke vorhanden!", "error");
            }
        });
         useManaPotionBtn.addEventListener('click', () => {
            const manaPotion = allInventoryItems.find(item => item.id === 'potion_mana_small');
            if (manaPotion && auth.currentUser) {
                useItem(auth.currentUser.uid, manaPotion.docId);
            } else {
                showNotification("Keine Manatränke vorhanden!", "error");
            }
        });


        // --- TEST BUTTONS ---
        document.getElementById('test-levelup-btn').addEventListener('click', () => {
            if (auth.currentUser) {
                handleXpGain(auth.currentUser.uid, 100);
            }
        });

        document.getElementById('test-add-bronze-btn').addEventListener('click', async () => {
            const userId = auth.currentUser?.uid;
            if (userId) {
                const userDocRef = doc(db, 'users', userId);
                await updateDoc(userDocRef, { 'currency.bronze': increment(125) });
                showNotification("+125 Bronze hinzugefügt.");
            }
        });
        
        document.getElementById('test-timer-usage-btn').addEventListener('click', async () => {
            const userId = auth.currentUser?.uid;
            if (userId) {
                const userDocRef = doc(db, 'users', userId);
                await updateDoc(userDocRef, { pomodorosCompleted: increment(1) });
                const updatedUserProfile = (await getDoc(userDocRef)).data();
                await checkAndGrantAchievements(userId, updatedUserProfile);
                showNotification("Timer-Nutzung +1");
            }
        });
        
        document.getElementById('test-gain-pet-xp-btn').addEventListener('click', () => {
            if (currentUserProfile?.activePets?.length > 0) {
                const petId = currentUserProfile.activePets[comparedActivePetSlotIndex];
                if (petId) {
                    gainPetXp(petId, 50);
                    showNotification(`+50 XP für ${currentUserProfile.pets[petId].name} hinzugefügt.`);
                }
            } else {
                showNotification("Kein aktives Pet zum Trainieren ausgewählt.", "error");
            }
        });


        document.getElementById('test-add-today-quests-btn').addEventListener('click', async () => {
            const userId = auth.currentUser?.uid;
            if (!userId) return;

            const ganttDate = new Date(document.getElementById('gantt-date').value);
            const [startHour, startMinute] = document.getElementById('gantt-start-time').value.split(':');
            ganttDate.setHours(startHour, startMinute, 0, 0);
            
            let nextAvailableTime = ganttDate.getTime();
            
            const batch = writeBatch(db);
            const newQuestRefs = [];
            for (let i = 0; i < 5; i++) {
                const newQuestRef = doc(collection(db, 'todos'));
                newQuestRefs.push(newQuestRef);
                 batch.set(newQuestRef, {
                    userId: userId,
                    text: `Heutige Aufgabe #${i + 1}`,
                    priority: 'Mittel',
                    taskType: 'Aufgabe',
                    durationMinutes: 60,
                    tags: ['Test'],
                    createdAt: serverTimestamp(),
                    ganttScheduledAt: Timestamp.fromMillis(nextAvailableTime),
                    deadline: Timestamp.fromMillis(nextAvailableTime + 24 * 60 * 60 * 1000) // Deadline tomorrow
                });
                nextAvailableTime += 60 * 60 * 1000;
            }
            await batch.commit();
            
            // Auto-focus the first quest
            if (newQuestRefs.length > 0) {
                const firstQuestId = newQuestRefs[0].id;
                const questToFocus = localQuests.find(q => q.id === firstQuestId);
                if (questToFocus) startFocusSession(questToFocus);
            }
            showNotification("5 neue Quests für heute erstellt, geplant und die erste fokussiert.");
        });

         document.getElementById('test-complete-all-quests-btn').addEventListener('click', async () => {
            if (!auth.currentUser || localQuests.length === 0) return;
            
            showNotification("Erledige alle Quests...", "info");
            const questsToComplete = [...localQuests];
            const completionPromises = questsToComplete.map(quest => handleQuestCompletion(quest.id));
            await Promise.all(completionPromises);
            showNotification("Alle Quests wurden erledigt!", "success");
        });


        document.querySelectorAll('.add-test-quests-btn').forEach(btn => {
            btn.addEventListener('click', async () => {
                if (!auth.currentUser) return;
                const count = parseInt(btn.dataset.count, 10);
                const priority = btn.dataset.priority;
                const userId = auth.currentUser.uid;
                
                showNotification(`Füge ${count} ${priority} Quests hinzu...`);

                const batch = writeBatch(db);
                const today = new Date();
                const deadline = new Date();
                deadline.setDate(today.getDate() + 7);

                for (let i = 0; i < count; i++) {
                    const newQuestRef = doc(collection(db, 'todos'));
                    batch.set(newQuestRef, {
                         userId: userId,
                         text: `Test Quest ${priority} #${i + 1}`,
                         priority: priority,
                         taskType: 'Aufgabe',
                         durationMinutes: Math.floor(Math.random() * 9 + 2) * 5, // 10 to 50 mins in 5min steps
                         tags: [availableTags[Math.floor(Math.random() * availableTags.length)]],
                         createdAt: serverTimestamp(),
                         deadline: Timestamp.fromDate(deadline)
                    });
                }
                await batch.commit();
            });
        });
    </script>
</body>
</html>